<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>C++ STL & DSA Reference</title>
<style>
  :root {
    --bg: #0f172a;
    --surface: #1e293b;
    --surface2: #334155;
    --border: #475569;
    --text: #e2e8f0;
    --text-muted: #94a3b8;
    --accent: #38bdf8;
    --accent2: #818cf8;
    --green: #4ade80;
    --yellow: #fbbf24;
    --red: #f87171;
    --orange: #fb923c;
    --pink: #f472b6;
    --code-bg: #0d1117;
    --sidebar-w: 280px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  html { scroll-behavior: smooth; scroll-padding-top: 80px; }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
  }

  /* ‚îÄ‚îÄ TOP BAR ‚îÄ‚îÄ */
  .topbar {
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
    background: rgba(15, 23, 42, 0.92);
    backdrop-filter: blur(12px);
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; gap: 16px;
    padding: 0 24px; height: 64px;
  }
  .topbar .logo {
    font-size: 1.25rem; font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    white-space: nowrap;
  }
  .topbar .logo span { font-weight: 400; opacity: .7; -webkit-text-fill-color: var(--text-muted); }

  .search-box {
    flex: 1; max-width: 520px; position: relative;
  }
  .search-box input {
    width: 100%; padding: 10px 16px 10px 42px;
    border-radius: 10px; border: 1px solid var(--border);
    background: var(--surface); color: var(--text);
    font-size: .95rem; outline: none; transition: .2s;
  }
  .search-box input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(56,189,248,.15); }
  .search-box .icon {
    position: absolute; left: 14px; top: 50%; transform: translateY(-50%);
    color: var(--text-muted); pointer-events: none;
  }
  .search-box .shortcut {
    position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
    font-size: .7rem; color: var(--text-muted); background: var(--surface2);
    padding: 2px 8px; border-radius: 4px; border: 1px solid var(--border);
  }

  .hamburger {
    display: none; background: none; border: none; color: var(--text);
    font-size: 1.5rem; cursor: pointer; padding: 4px;
  }

  /* ‚îÄ‚îÄ SIDEBAR ‚îÄ‚îÄ */
  .sidebar {
    position: fixed; top: 64px; left: 0; bottom: 0;
    width: var(--sidebar-w); background: var(--surface);
    border-right: 1px solid var(--border);
    overflow-y: auto; padding: 16px 0; z-index: 90;
    transition: transform .3s;
  }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

  .sidebar .nav-group { margin-bottom: 8px; }
  .sidebar .nav-group-title {
    padding: 8px 20px; font-size: .7rem; font-weight: 700;
    text-transform: uppercase; letter-spacing: .1em; color: var(--text-muted);
  }
  .sidebar a {
    display: flex; align-items: center; gap: 10px;
    padding: 8px 20px; color: var(--text-muted);
    text-decoration: none; font-size: .88rem;
    border-left: 3px solid transparent; transition: .15s;
  }
  .sidebar a:hover { background: var(--surface2); color: var(--text); }
  .sidebar a.active { border-left-color: var(--accent); color: var(--accent); background: rgba(56,189,248,.08); }
  .sidebar .nav-icon { font-size: 1.1rem; width: 22px; text-align: center; }

  /* ‚îÄ‚îÄ MAIN ‚îÄ‚îÄ */
  .main {
    margin-left: var(--sidebar-w); margin-top: 64px;
    padding: 32px 40px 80px;
    max-width: 1200px;
  }

  /* ‚îÄ‚îÄ SECTIONS ‚îÄ‚îÄ */
  .section { margin-bottom: 48px; }
  .section-header {
    display: flex; align-items: center; gap: 12px;
    margin-bottom: 20px; padding-bottom: 12px;
    border-bottom: 2px solid var(--surface2);
  }
  .section-header .num {
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    color: #fff; font-weight: 700; font-size: .85rem;
    width: 32px; height: 32px; border-radius: 8px;
    display: flex; align-items: center; justify-content: center; flex-shrink: 0;
  }
  .section-header h2 { font-size: 1.5rem; font-weight: 700; }
  .section-header .badge {
    font-size: .7rem; padding: 3px 10px; border-radius: 20px;
    background: var(--surface2); color: var(--text-muted); margin-left: auto; white-space: nowrap;
  }

  .desc {
    background: var(--surface); border-radius: 10px;
    padding: 14px 18px; margin-bottom: 20px;
    border-left: 4px solid var(--accent);
    color: var(--text-muted); font-size: .92rem;
  }
  .desc strong { color: var(--text); }

  /* ‚îÄ‚îÄ CODE BLOCKS ‚îÄ‚îÄ */
  pre {
    background: var(--code-bg); border-radius: 8px;
    padding: 14px 16px; overflow-x: auto;
    font-family: 'Fira Code', 'SF Mono', 'Cascadia Code', monospace;
    font-size: .82rem; line-height: 1.7;
    border: 1px solid var(--surface2); margin: 12px 0;
  }
  pre .cmt { color: var(--text-muted); font-style: italic; }
  pre .kw { color: var(--pink); }
  pre .type { color: var(--accent2); }
  pre .fn { color: var(--accent); }
  pre .str { color: var(--green); }
  pre .num { color: var(--orange); }

  /* ‚îÄ‚îÄ METHOD CARDS ‚îÄ‚îÄ */
  .method-card {
    background: var(--surface); border-radius: 12px;
    border: 1px solid var(--surface2);
    margin-bottom: 14px; overflow: hidden;
    transition: border-color .2s;
  }
  .method-card:hover { border-color: var(--border); }
  .method-card.open .card-body { display: block; }
  .method-card.open .chevron { transform: rotate(90deg); }

  .card-head {
    display: flex; align-items: center; gap: 12px;
    padding: 14px 18px; cursor: pointer; user-select: none;
  }
  .card-head:hover { background: rgba(255,255,255,.02); }
  .card-head .fn-name {
    font-family: 'Fira Code', 'SF Mono', 'Cascadia Code', monospace;
    font-size: .95rem; color: var(--green); font-weight: 600;
  }
  .card-head .fn-desc {
    font-size: .82rem; color: var(--text-muted); flex: 1;
  }
  .card-head .complexity {
    font-size: .7rem; padding: 2px 10px; border-radius: 20px;
    font-weight: 600; white-space: nowrap;
  }
  .complexity.o1 { background: rgba(74,222,128,.12); color: var(--green); }
  .complexity.ologn { background: rgba(251,191,36,.12); color: var(--yellow); }
  .complexity.on { background: rgba(251,146,60,.12); color: var(--orange); }
  .complexity.onlogn { background: rgba(248,113,113,.12); color: var(--red); }
  .complexity.other { background: rgba(129,140,248,.12); color: var(--accent2); }
  .chevron { color: var(--text-muted); transition: transform .2s; font-size: .8rem; }

  .card-body { display: none; padding: 0 18px 16px; }
  .card-body p { font-size: .88rem; color: var(--text-muted); margin-bottom: 8px; }
  .card-body .note { color: var(--yellow); font-size: .82rem; }

  /* ‚îÄ‚îÄ COMPLEXITY TABLE ‚îÄ‚îÄ */
  .complexity-table {
    width: 100%; border-collapse: collapse;
    background: var(--surface); border-radius: 12px; overflow: hidden;
    border: 1px solid var(--surface2);
  }
  .complexity-table th {
    background: var(--surface2); padding: 12px 16px;
    text-align: left; font-size: .8rem; text-transform: uppercase;
    letter-spacing: .05em; color: var(--text-muted);
  }
  .complexity-table td {
    padding: 10px 16px; border-top: 1px solid var(--surface2);
    font-size: .88rem;
  }
  .complexity-table tr:hover td { background: rgba(255,255,255,.02); }
  .complexity-table .ds-name { font-weight: 600; color: var(--accent); font-family: monospace; }

  /* ‚îÄ‚îÄ PATTERNS ‚îÄ‚îÄ */
  .pattern-card {
    background: var(--surface); border-radius: 10px;
    padding: 16px 20px; border: 1px solid var(--surface2);
    margin-bottom: 12px;
  }
  .pattern-card h3 { 
    font-size: 1rem; color: var(--accent); margin-bottom: 8px;
    display: flex; align-items: center; gap: 8px;
  }
  .pattern-card .badge-pattern {
    font-size: .7rem; padding: 2px 8px; border-radius: 12px;
    background: var(--surface2); color: var(--text-muted); font-weight: 600;
  }
  .pattern-card p { font-size: .88rem; color: var(--text-muted); margin-bottom: 8px; }

  /* ‚îÄ‚îÄ SEARCH RESULTS ‚îÄ‚îÄ */
  .search-overlay {
    display: none; position: fixed; inset: 0; z-index: 200;
    background: rgba(0,0,0,.6); backdrop-filter: blur(4px);
  }
  .search-overlay.show { display: flex; justify-content: center; padding-top: 100px; }
  .search-results {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 14px; width: 580px; max-height: 60vh;
    overflow-y: auto; padding: 8px;
  }
  .search-results .sr-item {
    padding: 10px 14px; border-radius: 8px; cursor: pointer;
    display: flex; flex-direction: column; gap: 2px;
  }
  .search-results .sr-item:hover, .search-results .sr-item.active { background: var(--surface2); }
  .search-results .sr-item .sr-title { font-weight: 600; font-size: .92rem; }
  .search-results .sr-item .sr-section { font-size: .78rem; color: var(--text-muted); }
  .search-results .sr-item mark { background: rgba(56,189,248,.25); color: var(--accent); border-radius: 2px; }
  .search-results .sr-empty { padding: 24px; text-align: center; color: var(--text-muted); }

  /* ‚îÄ‚îÄ BACK TO TOP ‚îÄ‚îÄ */
  .btt {
    position: fixed; bottom: 28px; right: 28px;
    width: 44px; height: 44px; border-radius: 12px;
    background: var(--accent); color: var(--bg);
    border: none; cursor: pointer; font-size: 1.2rem;
    display: none; align-items: center; justify-content: center;
    box-shadow: 0 4px 16px rgba(56,189,248,.3); transition: .2s; z-index: 50;
  }
  .btt:hover { transform: translateY(-2px); }
  .btt.show { display: flex; }

  /* ‚îÄ‚îÄ RESPONSIVE ‚îÄ‚îÄ */
  @media (max-width: 840px) {
    .sidebar { transform: translateX(-100%); }
    .sidebar.open { transform: translateX(0); box-shadow: 4px 0 24px rgba(0,0,0,.4); }
    .main { margin-left: 0; padding: 24px 18px 60px; }
    .hamburger { display: block; }
    .topbar .logo span { display: none; }
    .search-box .shortcut { display: none; }
    .search-results { width: 95vw; }
  }
</style>
</head>
<body>

<!-- ‚ïê‚ïê‚ïê TOP BAR ‚ïê‚ïê‚ïê -->
<header class="topbar">
  <button class="hamburger" onclick="document.querySelector('.sidebar').classList.toggle('open')" aria-label="Menu">‚ò∞</button>
  <div class="logo">C++ STL<span> Reference</span></div>
  <div class="search-box">
    <span class="icon">üîç</span>
    <input id="searchInput" type="text" placeholder="Search containers, algorithms, patterns‚Ä¶" autocomplete="off">
    <span class="shortcut">Ctrl K</span>
  </div>
</header>

<!-- ‚ïê‚ïê‚ïê SIDEBAR ‚ïê‚ïê‚ïê -->
<nav class="sidebar" id="sidebar">
  <div class="nav-group">
    <div class="nav-group-title">Containers</div>
    <a href="#pair"><span class="nav-icon">üîó</span> Pair</a>
    <a href="#vector"><span class="nav-icon">üìä</span> Vector</a>
    <a href="#string"><span class="nav-icon">üî§</span> String</a>
    <a href="#list"><span class="nav-icon">üîó</span> List</a>
    <a href="#deque"><span class="nav-icon">üîÑ</span> Deque</a>
    <a href="#stack"><span class="nav-icon">üìö</span> Stack</a>
    <a href="#queue"><span class="nav-icon">üö¶</span> Queue</a>
    <a href="#priority_queue"><span class="nav-icon">‚õ∞Ô∏è</span> Priority Queue</a>
  </div>
  <div class="nav-group">
    <div class="nav-group-title">Associative</div>
    <a href="#set"><span class="nav-icon">üîò</span> Set</a>
    <a href="#multiset"><span class="nav-icon">üîò</span> Multiset</a>
    <a href="#unordered_set"><span class="nav-icon">#Ô∏è‚É£</span> Unordered Set</a>
    <a href="#map"><span class="nav-icon">üóÇÔ∏è</span> Map</a>
    <a href="#multimap"><span class="nav-icon">üóÇÔ∏è</span> Multimap</a>
    <a href="#unordered_map"><span class="nav-icon">#Ô∏è‚É£</span> Unordered Map</a>
  </div>
  <div class="nav-group">
    <div class="nav-group-title">Algorithms & Utils</div>
    <a href="#iterators"><span class="nav-icon">üîÅ</span> Iterators</a>
    <a href="#algorithms"><span class="nav-icon">‚ö°</span> Algorithms</a>
    <a href="#numeric"><span class="nav-icon">üìê</span> Numeric</a>
    <a href="#bits"><span class="nav-icon">üíæ</span> Bit Manipulation</a>
    <a href="#lambda"><span class="nav-icon">Œª</span> Lambda & Comparators</a>
    <a href="#tuple"><span class="nav-icon">üì¶</span> Tuple</a>
    <a href="#stdarray"><span class="nav-icon">üìê</span> std::array</a>
    <a href="#bitset"><span class="nav-icon">üî¢</span> Bitset</a>
  </div>
  <div class="nav-group">
    <div class="nav-group-title">DSA Patterns</div>
    <a href="#patterns"><span class="nav-icon">üí°</span> Common Patterns</a>
    <a href="#complexity"><span class="nav-icon">üìä</span> Complexity Table</a>
  </div>
</nav>

<!-- ‚ïê‚ïê‚ïê SEARCH OVERLAY ‚ïê‚ïê‚ïê -->
<div class="search-overlay" id="searchOverlay" onclick="if(event.target===this)closeSearch()">
  <div class="search-results" id="searchResults"></div>
</div>

<!-- ‚ïê‚ïê‚ïê MAIN CONTENT ‚ïê‚ïê‚ïê -->
<main class="main" id="content">

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1. PAIR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="pair">
  <div class="section-header">
    <span class="num">1</span>
    <h2>Pair</h2>
    <span class="badge">&lt;utility&gt; ¬∑ Two Values</span>
  </div>
  <div class="desc">
    Stores two values (possibly different types). Access with <strong>.first</strong> and <strong>.second</strong>. Compared lexicographically.
  </div>

  <pre><span class="cmt">// Creation:</span>
pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; p1;               <span class="cmt">// default</span>
pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; p2(<span class="num">10</span>, <span class="str">'a'</span>);      <span class="cmt">// parameterized</span>
pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; p3 = {<span class="num">10</span>, <span class="str">'a'</span>};   <span class="cmt">// brace init</span>
<span class="kw">auto</span> p4 = <span class="fn">make_pair</span>(<span class="num">10</span>, <span class="str">'a'</span>);     <span class="cmt">// make_pair</span>

<span class="cmt">// Access:</span>
p1.first = <span class="num">10</span>;
p1.second = <span class="str">'a'</span>;

<span class="cmt">// Nested Pair:</span>
pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; np = {<span class="num">1</span>, {<span class="num">2</span>, <span class="num">3</span>}};
<span class="cmt">// np.first = 1, np.second.first = 2, np.second.second = 3</span></pre>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2. VECTOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="vector">
  <div class="section-header">
    <span class="num">2</span>
    <h2>Vector</h2>
    <span class="badge">&lt;vector&gt; ¬∑ Dynamic Array</span>
  </div>
  <div class="desc">
    Dynamic array with contiguous memory. <strong>O(1)</strong> random access. <strong>O(1)</strong> amortized insert/delete at end. <strong>O(n)</strong> in middle.
  </div>

  <div class="method-card" data-search="vector declaration initialize size">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Declaration & Initialization</span>
      <span class="fn-desc">Multiple ways to create vectors</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>vector&lt;<span class="type">int</span>&gt; v;                    <span class="cmt">// empty</span>
vector&lt;<span class="type">int</span>&gt; v(<span class="num">5</span>);                 <span class="cmt">// 5 elements, default 0</span>
vector&lt;<span class="type">int</span>&gt; v(<span class="num">5</span>, <span class="num">10</span>);            <span class="cmt">// 5 elements, all 10</span>
vector&lt;<span class="type">int</span>&gt; v = {<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>};   <span class="cmt">// initializer list</span>
vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat(n, vector&lt;<span class="type">int</span>&gt;(m, <span class="num">0</span>)); <span class="cmt">// n√óm matrix</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="push_back emplace_back add insert vector">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">push_back(x) / emplace_back(x)</span>
      <span class="fn-desc">Add element to end</span>
      <span class="complexity o1">O(1) amortized</span>
    </div>
    <div class="card-body">
      <pre>v.<span class="fn">push_back</span>(<span class="num">10</span>);     <span class="cmt">// O(1) amortized</span>
v.<span class="fn">emplace_back</span>(<span class="num">20</span>);   <span class="cmt">// O(1) ‚Äî construct in-place (faster)</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="pop_back remove delete last vector">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">pop_back()</span>
      <span class="fn-desc">Remove last element</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>v.<span class="fn">pop_back</span>();  <span class="cmt">// O(1) ‚Äî removes last element</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="size capacity empty vector">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">size() / capacity() / empty()</span>
      <span class="fn-desc">Size and capacity checks</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>v.<span class="fn">size</span>()           <span class="cmt">// O(1) ‚Äî number of elements</span>
v.<span class="fn">capacity</span>()       <span class="cmt">// O(1) ‚Äî allocated capacity</span>
v.<span class="fn">empty</span>()          <span class="cmt">// O(1) ‚Äî true if empty</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="access front back at vector indexing">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Access: [i] / at(i) / front() / back()</span>
      <span class="fn-desc">Element access methods</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>v[i]               <span class="cmt">// O(1) ‚Äî no bounds checking</span>
v.<span class="fn">at</span>(i)            <span class="cmt">// O(1) ‚Äî throws out_of_range</span>
v.<span class="fn">front</span>()          <span class="cmt">// O(1) ‚Äî first element</span>
v.<span class="fn">back</span>()           <span class="cmt">// O(1) ‚Äî last element</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="insert erase clear vector modify">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">insert(it, x) / erase(it) / clear()</span>
      <span class="fn-desc">Insert and erase operations</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>v.<span class="fn">insert</span>(v.begin() + i, x);    <span class="cmt">// O(n) ‚Äî insert at position</span>
v.<span class="fn">erase</span>(v.begin() + i);        <span class="cmt">// O(n) ‚Äî remove element</span>
v.<span class="fn">erase</span>(v.begin(), v.end());   <span class="cmt">// O(n) ‚Äî remove range</span>
v.<span class="fn">clear</span>();                     <span class="cmt">// O(n) ‚Äî remove all</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="resize reserve shrink_to_fit vector capacity memory">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">resize() / reserve() / shrink_to_fit()</span>
      <span class="fn-desc">Memory management</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>v.<span class="fn">resize</span>(<span class="num">10</span>);          <span class="cmt">// O(n) ‚Äî resize to 10, new elements = 0</span>
v.<span class="fn">resize</span>(<span class="num">10</span>, <span class="num">5</span>);       <span class="cmt">// O(n) ‚Äî resize to 10, new elements = 5</span>
v.<span class="fn">reserve</span>(<span class="num">100</span>);        <span class="cmt">// O(n) ‚Äî pre-allocate capacity (no size change)</span>
v.<span class="fn">shrink_to_fit</span>();     <span class="cmt">// O(n) ‚Äî reduce capacity to size</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="assign swap data vector">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">assign() / swap() / data()</span>
      <span class="fn-desc">Replace content, swap, raw pointer</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>v.<span class="fn">assign</span>(<span class="num">5</span>, <span class="num">10</span>);      <span class="cmt">// O(n) ‚Äî replace with 5 copies of 10</span>
v.<span class="fn">assign</span>({<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>});    <span class="cmt">// O(n) ‚Äî replace with initializer list</span>
v.<span class="fn">swap</span>(v2);            <span class="cmt">// O(1) ‚Äî swap contents with v2</span>
<span class="type">int</span>* ptr = v.<span class="fn">data</span>();  <span class="cmt">// O(1) ‚Äî raw pointer to underlying array</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="begin end rbegin rend iterators vector">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Iterators: begin/end/rbegin/rend</span>
      <span class="fn-desc">Iterator access</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>v.<span class="fn">begin</span>()    <span class="cmt">// iterator to first element</span>
v.<span class="fn">end</span>()      <span class="cmt">// iterator past last element</span>
v.<span class="fn">rbegin</span>()   <span class="cmt">// reverse iterator to last element</span>
v.<span class="fn">rend</span>()     <span class="cmt">// reverse iterator before first element</span>
<span class="cmt">// Also: cbegin(), cend(), crbegin(), crend() ‚Äî const versions</span>

<span class="cmt">// Iteration:</span>
<span class="kw">for</span> (<span class="kw">auto</span> it = v.<span class="fn">begin</span>(); it != v.<span class="fn">end</span>(); ++it) { <span class="cmt">/* *it */</span> }
<span class="kw">for</span> (<span class="kw">auto</span>&amp; x : v) { <span class="cmt">/* range-based for */</span> }</pre>
    </div>
  </div>

  <div class="method-card" data-search="sort reverse min max vector algorithms">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Common Operations</span>
      <span class="fn-desc">Sorting, reversing, finding min/max</span>
      <span class="complexity onlogn">O(n log n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">sort</span>(v.begin(), v.end());              <span class="cmt">// O(n log n)</span>
<span class="fn">reverse</span>(v.begin(), v.end());           <span class="cmt">// O(n)</span>
<span class="type">int</span> mx = *<span class="fn">max_element</span>(v.begin(), v.end());  <span class="cmt">// O(n)</span>
<span class="type">int</span> mn = *<span class="fn">min_element</span>(v.begin(), v.end());  <span class="cmt">// O(n)</span>
<span class="type">int</span> sum = <span class="fn">accumulate</span>(v.begin(), v.end(), <span class="num">0</span>); <span class="cmt">// O(n)</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3. STRING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="string">
  <div class="section-header">
    <span class="num">3</span>
    <h2>String</h2>
    <span class="badge">&lt;string&gt; ¬∑ Dynamic Character Array</span>
  </div>
  <div class="desc">
    Dynamic character array. Mutable unlike Java/Python strings. <strong>O(1)</strong> access, various O(n) operations.
  </div>

  <div class="method-card" data-search="string declaration initialize">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Declaration & Initialization</span>
      <span class="fn-desc">Creating strings</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>string s = <span class="str">"hello"</span>;
string s(<span class="num">5</span>, <span class="str">'a'</span>);    <span class="cmt">// "aaaaa"</span>
string s2 = s;       <span class="cmt">// copy</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="string append push_back concatenate">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">append() / push_back() / +=</span>
      <span class="fn-desc">Add characters/strings</span>
      <span class="complexity on">O(k)</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">push_back</span>(<span class="str">'c'</span>);   <span class="cmt">// O(1) amortized</span>
s.<span class="fn">append</span>(<span class="str">"world"</span>);   <span class="cmt">// O(k)</span>
s += <span class="str">"world"</span>;        <span class="cmt">// O(k) ‚Äî same as append</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="string find rfind search">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">find() / rfind()</span>
      <span class="fn-desc">Search for substring</span>
      <span class="complexity on">O(n*m)</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">find</span>(<span class="str">"sub"</span>)      <span class="cmt">// returns index or string::npos</span>
s.<span class="fn">rfind</span>(<span class="str">"sub"</span>)     <span class="cmt">// reverse find (last occurrence)</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="string substr substring extract">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">substr(pos, len)</span>
      <span class="fn-desc">Extract substring</span>
      <span class="complexity on">O(len)</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">substr</span>(pos, len) <span class="cmt">// O(len) ‚Äî extract substring</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="string size length empty clear">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">size() / length() / empty() / clear()</span>
      <span class="fn-desc">Size and state checks</span>
      <span class="complexity o1">O(1)*</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">size</span>()           <span class="cmt">// O(1) ‚Äî number of characters</span>
s.<span class="fn">length</span>()         <span class="cmt">// O(1) ‚Äî same as size()</span>
s.<span class="fn">empty</span>()          <span class="cmt">// O(1) ‚Äî true if empty</span>
s.<span class="fn">clear</span>()          <span class="cmt">// O(n) ‚Äî remove all characters</span>
s.<span class="fn">resize</span>(<span class="num">10</span>)       <span class="cmt">// O(n) ‚Äî resize to 10 chars</span>
s.<span class="fn">resize</span>(<span class="num">10</span>, <span class="str">'x'</span>) <span class="cmt">// O(n) ‚Äî resize, pad with 'x'</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="string access front back at operator">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Access: [i] / at(i) / front() / back()</span>
      <span class="fn-desc">Character access</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>s[i]               <span class="cmt">// O(1) ‚Äî no bounds checking</span>
s.<span class="fn">at</span>(i)            <span class="cmt">// O(1) ‚Äî throws out_of_range</span>
s.<span class="fn">front</span>()          <span class="cmt">// O(1) ‚Äî first character</span>
s.<span class="fn">back</span>()           <span class="cmt">// O(1) ‚Äî last character</span>
s.<span class="fn">c_str</span>()          <span class="cmt">// O(1) ‚Äî const char* (null-terminated)</span>
s.<span class="fn">data</span>()           <span class="cmt">// O(1) ‚Äî pointer to underlying data</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="string erase insert replace modify">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">erase() / insert() / replace()</span>
      <span class="fn-desc">Modify string content</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">erase</span>(pos, len)          <span class="cmt">// O(n) ‚Äî remove len chars from pos</span>
s.<span class="fn">erase</span>(it)                <span class="cmt">// O(n) ‚Äî remove single char at iterator</span>
s.<span class="fn">erase</span>(it1, it2)           <span class="cmt">// O(n) ‚Äî remove range</span>
s.<span class="fn">insert</span>(pos, <span class="str">"text"</span>)       <span class="cmt">// O(n) ‚Äî insert at position</span>
s.<span class="fn">insert</span>(pos, n, <span class="str">'c'</span>)      <span class="cmt">// O(n) ‚Äî insert n copies of 'c'</span>
s.<span class="fn">replace</span>(pos, len, <span class="str">"new"</span>) <span class="cmt">// O(n) ‚Äî replace len chars from pos</span>
s.<span class="fn">pop_back</span>()               <span class="cmt">// O(1) ‚Äî remove last character</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="string compare c_str swap">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">compare() / swap()</span>
      <span class="fn-desc">Compare and swap strings</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">compare</span>(s2)              <span class="cmt">// O(n) ‚Äî &lt;0 if s&lt;s2, 0 if equal, &gt;0 if s&gt;s2</span>
s.<span class="fn">compare</span>(pos, len, s2)     <span class="cmt">// O(n) ‚Äî compare substring</span>
s.<span class="fn">swap</span>(s2)                  <span class="cmt">// O(1) ‚Äî swap contents</span>
<span class="cmt">// Comparison operators: ==, !=, &lt;, &gt;, &lt;=, &gt;= work directly</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="string stoi stol stoll convert">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">String Conversion</span>
      <span class="fn-desc">String to number and vice versa</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">stoi</span>(s)            <span class="cmt">// string to int</span>
<span class="fn">stol</span>(s)            <span class="cmt">// string to long</span>
<span class="fn">stoll</span>(s)           <span class="cmt">// string to long long</span>
<span class="fn">stod</span>(s)            <span class="cmt">// string to double</span>
<span class="fn">to_string</span>(<span class="num">42</span>)      <span class="cmt">// int/float to string</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="string isalpha isdigit isalnum tolower toupper character">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Character Functions</span>
      <span class="fn-desc">Character classification and conversion</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// #include &lt;cctype&gt;</span>
<span class="fn">isalpha</span>(c)    <span class="cmt">// true if letter</span>
<span class="fn">isdigit</span>(c)    <span class="cmt">// true if digit 0-9</span>
<span class="fn">isalnum</span>(c)    <span class="cmt">// true if letter or digit</span>
<span class="fn">isspace</span>(c)    <span class="cmt">// true if whitespace</span>
<span class="fn">isupper</span>(c)    <span class="cmt">// true if uppercase</span>
<span class="fn">islower</span>(c)    <span class="cmt">// true if lowercase</span>
<span class="fn">tolower</span>(c)    <span class="cmt">// convert to lowercase</span>
<span class="fn">toupper</span>(c)    <span class="cmt">// convert to uppercase</span>

<span class="cmt">// Convert entire string to lowercase:</span>
<span class="fn">transform</span>(s.begin(), s.end(), s.begin(), ::<span class="fn">tolower</span>);</pre>
    </div>
  </div>

  <div class="method-card" data-search="string starts_with ends_with contains C++20 C++23">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">starts_with() / ends_with() / contains()</span>
      <span class="fn-desc">Modern string checks (C++20/23)</span>
      <span class="complexity on">O(k)</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// C++20:</span>
s.<span class="fn">starts_with</span>(<span class="str">"pre"</span>)   <span class="cmt">// true if s starts with "pre"</span>
s.<span class="fn">ends_with</span>(<span class="str">"suf"</span>)     <span class="cmt">// true if s ends with "suf"</span>
<span class="cmt">// C++23:</span>
s.<span class="fn">contains</span>(<span class="str">"mid"</span>)      <span class="cmt">// true if s contains "mid"</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 4. LIST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="list">
  <div class="section-header">
    <span class="num">4</span>
    <h2>List (Doubly Linked List)</h2>
    <span class="badge">&lt;list&gt; ¬∑ O(1) Insert/Delete</span>
  </div>
  <div class="desc">
    Doubly linked list. No random access. <strong>O(1)</strong> insert/delete anywhere with iterator.
  </div>

  <div class="method-card" data-search="list push_back push_front pop_back pop_front add remove">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">push/pop front & back</span>
      <span class="fn-desc">Add/remove at both ends</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>list&lt;<span class="type">int</span>&gt; l = {<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>};
l.<span class="fn">push_back</span>(x)     <span class="cmt">// O(1) ‚Äî add to end</span>
l.<span class="fn">push_front</span>(x)    <span class="cmt">// O(1) ‚Äî add to front</span>
l.<span class="fn">emplace_back</span>(x)  <span class="cmt">// O(1) ‚Äî construct at end</span>
l.<span class="fn">emplace_front</span>(x) <span class="cmt">// O(1) ‚Äî construct at front</span>
l.<span class="fn">pop_back</span>()       <span class="cmt">// O(1) ‚Äî remove last</span>
l.<span class="fn">pop_front</span>()      <span class="cmt">// O(1) ‚Äî remove first</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="list insert erase remove">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">insert() / erase() / remove()</span>
      <span class="fn-desc">Insert/erase with iterators, remove by value</span>
      <span class="complexity o1">O(1)*</span>
    </div>
    <div class="card-body">
      <pre>l.<span class="fn">insert</span>(it, x)    <span class="cmt">// O(1) ‚Äî insert before iterator</span>
l.<span class="fn">erase</span>(it)        <span class="cmt">// O(1) ‚Äî remove at iterator</span>
l.<span class="fn">erase</span>(it1, it2)   <span class="cmt">// O(n) ‚Äî remove range</span>
l.<span class="fn">remove</span>(val)      <span class="cmt">// O(n) ‚Äî remove all occurrences of val</span>
l.<span class="fn">remove_if</span>(pred)  <span class="cmt">// O(n) ‚Äî remove if predicate true</span>
l.<span class="fn">clear</span>()          <span class="cmt">// O(n) ‚Äî remove all elements</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="list front back size empty access">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">front() / back() / size() / empty()</span>
      <span class="fn-desc">Access and size checks</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>l.<span class="fn">front</span>()          <span class="cmt">// O(1) ‚Äî first element</span>
l.<span class="fn">back</span>()           <span class="cmt">// O(1) ‚Äî last element</span>
l.<span class="fn">size</span>()           <span class="cmt">// O(1) ‚Äî number of elements</span>
l.<span class="fn">empty</span>()          <span class="cmt">// O(1) ‚Äî true if empty</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="list sort reverse unique merge splice">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">sort / reverse / unique / merge / splice</span>
      <span class="fn-desc">List-specific operations</span>
      <span class="complexity onlogn">O(n log n)*</span>
    </div>
    <div class="card-body">
      <pre>l.<span class="fn">sort</span>()           <span class="cmt">// O(n log n) ‚Äî merge sort (stable)</span>
l.<span class="fn">sort</span>(greater&lt;<span class="type">int</span>&gt;())  <span class="cmt">// descending</span>
l.<span class="fn">reverse</span>()        <span class="cmt">// O(n)</span>
l.<span class="fn">unique</span>()         <span class="cmt">// O(n) ‚Äî remove consecutive duplicates (sort first!)</span>
l.<span class="fn">merge</span>(l2)        <span class="cmt">// O(n+m) ‚Äî merge sorted lists (l2 becomes empty)</span>
l.<span class="fn">splice</span>(it, l2)   <span class="cmt">// O(1) ‚Äî move all of l2 before it</span>
l.<span class="fn">splice</span>(it, l2, it2)  <span class="cmt">// O(1) ‚Äî move single element from l2</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 5. DEQUE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="deque">
  <div class="section-header">
    <span class="num">5</span>
    <h2>Deque (Double-Ended Queue)</h2>
    <span class="badge">&lt;deque&gt; ¬∑ Both Ends O(1)</span>
  </div>
  <div class="desc">
    Dynamic array with <strong>O(1)</strong> push/pop at both ends. Random access <strong>O(1)</strong>.
  </div>

  <div class="method-card" data-search="deque push_back push_front pop_back pop_front emplace">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">push/pop front & back</span>
      <span class="fn-desc">Add/remove at both ends</span>
      <span class="complexity o1">O(1) amortized</span>
    </div>
    <div class="card-body">
      <pre>deque&lt;<span class="type">int</span>&gt; dq = {<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>};
dq.<span class="fn">push_back</span>(x)    <span class="cmt">// O(1) amortized</span>
dq.<span class="fn">push_front</span>(x)   <span class="cmt">// O(1) amortized</span>
dq.<span class="fn">emplace_back</span>(x) <span class="cmt">// O(1) ‚Äî construct at back</span>
dq.<span class="fn">emplace_front</span>(x)<span class="cmt">// O(1) ‚Äî construct at front</span>
dq.<span class="fn">pop_back</span>()      <span class="cmt">// O(1)</span>
dq.<span class="fn">pop_front</span>()     <span class="cmt">// O(1)</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="deque access front back at indexing">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Access: [i] / at(i) / front() / back()</span>
      <span class="fn-desc">Random access and end elements</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>dq[i]              <span class="cmt">// O(1) ‚Äî random access (no bounds check)</span>
dq.<span class="fn">at</span>(i)           <span class="cmt">// O(1) ‚Äî bounds checked</span>
dq.<span class="fn">front</span>()         <span class="cmt">// O(1) ‚Äî first element</span>
dq.<span class="fn">back</span>()          <span class="cmt">// O(1) ‚Äî last element</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="deque insert erase clear size empty resize">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">insert / erase / size / clear / resize</span>
      <span class="fn-desc">Modify and query deque</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>dq.<span class="fn">insert</span>(it, x)   <span class="cmt">// O(n) ‚Äî insert at position</span>
dq.<span class="fn">erase</span>(it)       <span class="cmt">// O(n) ‚Äî erase at position</span>
dq.<span class="fn">erase</span>(it1, it2)  <span class="cmt">// O(n) ‚Äî erase range</span>
dq.<span class="fn">size</span>()          <span class="cmt">// O(1)</span>
dq.<span class="fn">empty</span>()         <span class="cmt">// O(1)</span>
dq.<span class="fn">clear</span>()         <span class="cmt">// O(n) ‚Äî remove all</span>
dq.<span class="fn">resize</span>(<span class="num">10</span>)      <span class="cmt">// O(n) ‚Äî resize</span>
dq.<span class="fn">swap</span>(dq2)       <span class="cmt">// O(1) ‚Äî swap contents</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 6. STACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="stack">
  <div class="section-header">
    <span class="num">6</span>
    <h2>Stack (LIFO)</h2>
    <span class="badge">&lt;stack&gt; ¬∑ Last In First Out</span>
  </div>
  <div class="desc">
    Last In First Out. <strong>O(1)</strong> for all operations. Use for DFS, expression evaluation, parentheses matching.
  </div>

  <div class="method-card" data-search="stack push emplace pop top add remove">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">push() / emplace() / pop() / top()</span>
      <span class="fn-desc">Core stack operations</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>stack&lt;<span class="type">int</span>&gt; st;
st.<span class="fn">push</span>(x)         <span class="cmt">// O(1) ‚Äî push to top</span>
st.<span class="fn">emplace</span>(x)      <span class="cmt">// O(1) ‚Äî construct at top</span>
st.<span class="fn">pop</span>()           <span class="cmt">// O(1) ‚Äî remove top (void, does NOT return)</span>
st.<span class="fn">top</span>()           <span class="cmt">// O(1) ‚Äî access top element</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="stack size empty swap">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">size() / empty() / swap()</span>
      <span class="fn-desc">Size checks and swap</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>st.<span class="fn">size</span>()          <span class="cmt">// O(1)</span>
st.<span class="fn">empty</span>()         <span class="cmt">// O(1)</span>
st.<span class="fn">swap</span>(st2)       <span class="cmt">// O(1) ‚Äî swap contents</span>

<span class="cmt">// Stack with different underlying container:</span>
stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; sv;    <span class="cmt">// vector-backed</span>
stack&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; sl;      <span class="cmt">// list-backed</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 7. QUEUE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="queue">
  <div class="section-header">
    <span class="num">7</span>
    <h2>Queue (FIFO)</h2>
    <span class="badge">&lt;queue&gt; ¬∑ First In First Out</span>
  </div>
  <div class="desc">
    First In First Out. <strong>O(1)</strong> operations. Use for BFS, level order traversal, scheduling.
  </div>

  <div class="method-card" data-search="queue push emplace pop front back enqueue dequeue">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">push() / emplace() / pop() / front() / back()</span>
      <span class="fn-desc">Core queue operations</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>queue&lt;<span class="type">int</span>&gt; q;
q.<span class="fn">push</span>(x)          <span class="cmt">// O(1) ‚Äî enqueue at back</span>
q.<span class="fn">emplace</span>(x)       <span class="cmt">// O(1) ‚Äî construct at back</span>
q.<span class="fn">pop</span>()            <span class="cmt">// O(1) ‚Äî dequeue from front (void)</span>
q.<span class="fn">front</span>()          <span class="cmt">// O(1) ‚Äî access front element</span>
q.<span class="fn">back</span>()           <span class="cmt">// O(1) ‚Äî access back element</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="queue size empty swap">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">size() / empty() / swap()</span>
      <span class="fn-desc">Size checks and swap</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>q.<span class="fn">size</span>()           <span class="cmt">// O(1)</span>
q.<span class="fn">empty</span>()          <span class="cmt">// O(1)</span>
q.<span class="fn">swap</span>(q2)          <span class="cmt">// O(1) ‚Äî swap contents</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 8. PRIORITY QUEUE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="priority_queue">
  <div class="section-header">
    <span class="num">8</span>
    <h2>Priority Queue (Heap)</h2>
    <span class="badge">&lt;queue&gt; ¬∑ Binary Heap</span>
  </div>
  <div class="desc">
    Binary heap. Default: max-heap. <strong>O(log n)</strong> push/pop. <strong>O(1)</strong> top. For min-heap use <code>greater&lt;int&gt;</code>.
  </div>

  <div class="method-card" data-search="priority_queue declaration max heap min heap greater">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Declaration (Max-Heap / Min-Heap)</span>
      <span class="fn-desc">Creating priority queues</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// Max-heap (default):</span>
priority_queue&lt;<span class="type">int</span>&gt; pq;

<span class="cmt">// Min-heap:</span>
priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minpq;

<span class="cmt">// Build from vector (heapify) ‚Äî O(n):</span>
priority_queue&lt;<span class="type">int</span>&gt; pq(v.begin(), v.end());</pre>
    </div>
  </div>

  <div class="method-card" data-search="priority_queue push emplace pop top">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">push() / emplace() / pop() / top()</span>
      <span class="fn-desc">Core heap operations</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>pq.<span class="fn">push</span>(x)         <span class="cmt">// O(log n) ‚Äî insert</span>
pq.<span class="fn">emplace</span>(x)      <span class="cmt">// O(log n) ‚Äî construct in-place</span>
pq.<span class="fn">pop</span>()           <span class="cmt">// O(log n) ‚Äî remove top (void)</span>
pq.<span class="fn">top</span>()           <span class="cmt">// O(1) ‚Äî access max/min element</span>
pq.<span class="fn">size</span>()          <span class="cmt">// O(1)</span>
pq.<span class="fn">empty</span>()         <span class="cmt">// O(1)</span>
pq.<span class="fn">swap</span>(pq2)       <span class="cmt">// O(1) ‚Äî swap contents</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="priority_queue custom comparator pair struct lambda">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Custom Comparators</span>
      <span class="fn-desc">Custom ordering with lambda or struct</span>
      <span class="complexity other">varies</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// Lambda comparator (C++11):</span>
<span class="kw">auto</span> cmp = [](<span class="kw">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; a, <span class="kw">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; b) {
    <span class="kw">return</span> a.second &gt; b.second; <span class="cmt">// min-heap on second element</span>
};
priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, decltype(cmp)&gt; pq(cmp);

<span class="cmt">// Struct comparator:</span>
<span class="kw">struct</span> Cmp {
    <span class="type">bool</span> <span class="kw">operator</span>()(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; b) {
        <span class="kw">return</span> a.first &gt; b.first; <span class="cmt">// min-heap on first</span>
    }
};
priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, Cmp&gt; pq;</pre>
      <p class="note">Note: PQ comparator logic is reversed ‚Äî return true if a should come AFTER b.</p>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 9. SET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="set">
  <div class="section-header">
    <span class="num">9</span>
    <h2>Set (Ordered, Unique)</h2>
    <span class="badge">&lt;set&gt; ¬∑ Red-Black Tree</span>
  </div>
  <div class="desc">
    Balanced BST (Red-Black Tree). Sorted, unique elements. All operations: <strong>O(log n)</strong>.
  </div>

  <div class="method-card" data-search="set insert emplace add">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">insert(x) / emplace(x)</span>
      <span class="fn-desc">Add element</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>set&lt;<span class="type">int</span>&gt; s = {<span class="num">3</span>, <span class="num">1</span>, <span class="num">4</span>, <span class="num">1</span>, <span class="num">5</span>}; <span class="cmt">// {1, 3, 4, 5}</span>
s.<span class="fn">insert</span>(x);        <span class="cmt">// O(log n)</span>
s.<span class="fn">emplace</span>(x);       <span class="cmt">// O(log n)</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="set erase remove delete">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">erase(x) / erase(it)</span>
      <span class="fn-desc">Remove element</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">erase</span>(x)         <span class="cmt">// O(log n) ‚Äî erase by value</span>
s.<span class="fn">erase</span>(it)        <span class="cmt">// O(1) amortized ‚Äî erase by iterator</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="set find count contains search">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">find(x) / count(x) / contains(x)</span>
      <span class="fn-desc">Search for element</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">find</span>(x)          <span class="cmt">// O(log n) ‚Äî returns iterator (or s.end())</span>
s.<span class="fn">count</span>(x)         <span class="cmt">// O(log n) ‚Äî 0 or 1</span>
s.<span class="fn">contains</span>(x)      <span class="cmt">// O(log n) ‚Äî C++20, returns bool</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="set size empty clear swap">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">size() / empty() / clear() / swap()</span>
      <span class="fn-desc">Size checks and utilities</span>
      <span class="complexity o1">O(1)*</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">size</span>()           <span class="cmt">// O(1) ‚Äî number of elements</span>
s.<span class="fn">empty</span>()          <span class="cmt">// O(1) ‚Äî true if empty</span>
s.<span class="fn">clear</span>()          <span class="cmt">// O(n) ‚Äî remove all elements</span>
s.<span class="fn">swap</span>(s2)          <span class="cmt">// O(1) ‚Äî swap contents</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="set begin end rbegin rend iterator">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Iterators & Traversal</span>
      <span class="fn-desc">Iterate in sorted order</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>s.<span class="fn">begin</span>()   <span class="cmt">// iterator to smallest element</span>
s.<span class="fn">end</span>()     <span class="cmt">// past-end iterator</span>
s.<span class="fn">rbegin</span>()  <span class="cmt">// reverse iterator to largest element</span>
s.<span class="fn">rend</span>()    <span class="cmt">// reverse past-begin</span>

<span class="cmt">// Iterate in sorted order:</span>
<span class="kw">for</span> (<span class="kw">auto</span>&amp; x : s) { <span class="cmt">/* ascending */</span> }

<span class="cmt">// Access smallest / largest:</span>
*s.<span class="fn">begin</span>()   <span class="cmt">// smallest element</span>
*s.<span class="fn">rbegin</span>()  <span class="cmt">// largest element</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="set equal_range">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">equal_range(x)</span>
      <span class="fn-desc">Range of elements equal to x</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre><span class="kw">auto</span> [lo, hi] = s.<span class="fn">equal_range</span>(x);
<span class="cmt">// lo = lower_bound(x), hi = upper_bound(x)</span>
<span class="cmt">// For set: range is at most 1 element</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 10. MULTISET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="multiset">
  <div class="section-header">
    <span class="num">10</span>
    <h2>Multiset (Ordered, Duplicates)</h2>
    <span class="badge">&lt;set&gt; ¬∑ Allows Duplicates</span>
  </div>
  <div class="desc">
    Like set but allows duplicate elements. All operations: <strong>O(log n)</strong>.
  </div>

  <div class="method-card" data-search="multiset insert erase find count">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">insert() / erase() / find() / count()</span>
      <span class="fn-desc">Core multiset operations</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>multiset&lt;<span class="type">int</span>&gt; ms;
ms.<span class="fn">insert</span>(<span class="num">5</span>); ms.<span class="fn">insert</span>(<span class="num">5</span>); ms.<span class="fn">insert</span>(<span class="num">3</span>);
<span class="cmt">// ms = {3, 5, 5}</span>

ms.<span class="fn">count</span>(<span class="num">5</span>)         <span class="cmt">// O(log n + count) ‚Äî number of occurrences</span>
ms.<span class="fn">find</span>(<span class="num">5</span>)          <span class="cmt">// O(log n) ‚Äî iterator to first occurrence</span>
ms.<span class="fn">erase</span>(<span class="num">5</span>)         <span class="cmt">// ‚ö† removes ALL occurrences of 5</span>
ms.<span class="fn">erase</span>(ms.<span class="fn">find</span>(<span class="num">5</span>))  <span class="cmt">// removes only ONE occurrence</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="multiset lower_bound upper_bound equal_range">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">lower_bound / upper_bound / equal_range</span>
      <span class="fn-desc">Range queries on duplicates</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>ms.<span class="fn">lower_bound</span>(x)   <span class="cmt">// first ‚â• x</span>
ms.<span class="fn">upper_bound</span>(x)   <span class="cmt">// first &gt; x</span>
<span class="kw">auto</span> [lo, hi] = ms.<span class="fn">equal_range</span>(x);
<span class="cmt">// [lo, hi) = all elements equal to x</span>
<span class="type">int</span> cnt = <span class="fn">distance</span>(lo, hi); <span class="cmt">// count of x</span>

<span class="cmt">// Useful: size, empty, clear, swap also available</span>
ms.<span class="fn">size</span>()     ms.<span class="fn">empty</span>()    ms.<span class="fn">clear</span>()</pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 11. UNORDERED SET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="unordered_set">
  <div class="section-header">
    <span class="num">11</span>
    <h2>Unordered Set (Hash Set)</h2>
    <span class="badge">&lt;unordered_set&gt; ¬∑ Hash Table</span>
  </div>
  <div class="desc">
    Hash table. Unique elements, no order. Average: <strong>O(1)</strong>. Worst: <strong>O(n)</strong>.
  </div>

  <div class="method-card" data-search="unordered_set insert erase find count contains">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">insert / erase / find / count / contains</span>
      <span class="fn-desc">Core hash set operations</span>
      <span class="complexity o1">O(1) average</span>
    </div>
    <div class="card-body">
      <pre>unordered_set&lt;<span class="type">int</span>&gt; us = {<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>};
us.<span class="fn">insert</span>(x)       <span class="cmt">// O(1) avg ‚Äî add element</span>
us.<span class="fn">emplace</span>(x)      <span class="cmt">// O(1) avg ‚Äî construct in-place</span>
us.<span class="fn">erase</span>(x)        <span class="cmt">// O(1) avg ‚Äî remove by value</span>
us.<span class="fn">erase</span>(it)       <span class="cmt">// O(1) avg ‚Äî remove by iterator</span>
us.<span class="fn">find</span>(x)         <span class="cmt">// O(1) avg ‚Äî returns iterator or end()</span>
us.<span class="fn">count</span>(x)        <span class="cmt">// O(1) avg ‚Äî 0 or 1</span>
us.<span class="fn">contains</span>(x)     <span class="cmt">// O(1) avg ‚Äî C++20, returns bool</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="unordered_set size empty clear reserve bucket load_factor">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">size / empty / clear / reserve / bucket info</span>
      <span class="fn-desc">Size checks and hash table tuning</span>
      <span class="complexity o1">O(1)*</span>
    </div>
    <div class="card-body">
      <pre>us.<span class="fn">size</span>()             <span class="cmt">// O(1)</span>
us.<span class="fn">empty</span>()            <span class="cmt">// O(1)</span>
us.<span class="fn">clear</span>()            <span class="cmt">// O(n)</span>
us.<span class="fn">reserve</span>(<span class="num">100</span>)       <span class="cmt">// pre-allocate buckets (reduces rehashing)</span>
us.<span class="fn">bucket_count</span>()    <span class="cmt">// number of buckets</span>
us.<span class="fn">load_factor</span>()     <span class="cmt">// elements / buckets ratio</span>
us.<span class="fn">max_load_factor</span>(<span class="num">0.25</span>) <span class="cmt">// set max load factor (anti-hash hack)</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 12. MAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="map">
  <div class="section-header">
    <span class="num">12</span>
    <h2>Map (Ordered Key-Value)</h2>
    <span class="badge">&lt;map&gt; ¬∑ Red-Black Tree</span>
  </div>
  <div class="desc">
    Balanced BST (Red-Black Tree). Sorted by key. Unique keys. All operations: <strong>O(log n)</strong>.
  </div>

  <div class="method-card" data-search="map access operator bracket at">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">[key] / at(key)</span>
      <span class="fn-desc">Access/create element</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>map&lt;string, <span class="type">int</span>&gt; mp;
mp[key]             <span class="cmt">// O(log n) ‚Äî access/create (creates if missing!)</span>
mp[key] = val       <span class="cmt">// O(log n) ‚Äî insert or update</span>
mp.<span class="fn">at</span>(key)          <span class="cmt">// O(log n) ‚Äî throws out_of_range if missing</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="map insert emplace add">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">insert({key,val}) / emplace(key,val)</span>
      <span class="fn-desc">Insert element</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>mp.<span class="fn">insert</span>({key,val})  <span class="cmt">// O(log n) ‚Äî insert only if key doesn't exist</span>
mp.<span class="fn">emplace</span>(key,val)   <span class="cmt">// O(log n) ‚Äî construct in-place</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="map find count contains search">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">find(key) / count(key) / contains(key)</span>
      <span class="fn-desc">Search for key</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>mp.<span class="fn">find</span>(key)        <span class="cmt">// O(log n) ‚Äî iterator or mp.end()</span>
mp.<span class="fn">count</span>(key)       <span class="cmt">// O(log n) ‚Äî 0 or 1</span>
mp.<span class="fn">contains</span>(key)    <span class="cmt">// O(log n) ‚Äî C++20</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="map iterate loop for">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Iteration</span>
      <span class="fn-desc">Loop through key-value pairs</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// C++17 structured bindings:</span>
<span class="kw">for</span> (<span class="kw">auto</span>&amp; [key, val] : mp) {
    <span class="cmt">// process key and val</span>
}</pre>
    </div>
  </div>

  <div class="method-card" data-search="map erase clear remove delete">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">erase() / clear()</span>
      <span class="fn-desc">Remove elements</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>mp.<span class="fn">erase</span>(key)       <span class="cmt">// O(log n) ‚Äî erase by key (returns count)</span>
mp.<span class="fn">erase</span>(it)        <span class="cmt">// O(1) amortized ‚Äî erase by iterator</span>
mp.<span class="fn">erase</span>(it1, it2)   <span class="cmt">// O(n) ‚Äî erase range</span>
mp.<span class="fn">clear</span>()           <span class="cmt">// O(n) ‚Äî remove all elements</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="map size empty swap">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">size() / empty() / swap()</span>
      <span class="fn-desc">Size checks and swap</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>mp.<span class="fn">size</span>()           <span class="cmt">// O(1) ‚Äî number of key-value pairs</span>
mp.<span class="fn">empty</span>()          <span class="cmt">// O(1) ‚Äî true if empty</span>
mp.<span class="fn">swap</span>(mp2)         <span class="cmt">// O(1) ‚Äî swap contents</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="map lower_bound upper_bound equal_range binary search">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">lower_bound / upper_bound / equal_range</span>
      <span class="fn-desc">Binary search on keys</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>mp.<span class="fn">lower_bound</span>(key)   <span class="cmt">// iterator to first key ‚â• key</span>
mp.<span class="fn">upper_bound</span>(key)   <span class="cmt">// iterator to first key &gt; key</span>
<span class="kw">auto</span> [lo, hi] = mp.<span class="fn">equal_range</span>(key);

<span class="cmt">// Iterator access: it-&gt;first (key), it-&gt;second (value)</span>
<span class="kw">auto</span> it = mp.<span class="fn">lower_bound</span>(key);
<span class="kw">if</span> (it != mp.end()) { <span class="cmt">/* it-&gt;first, it-&gt;second */</span> }</pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 13. MULTIMAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="multimap">
  <div class="section-header">
    <span class="num">13</span>
    <h2>Multimap (Ordered, Duplicate Keys)</h2>
    <span class="badge">&lt;map&gt; ¬∑ Allows Duplicates</span>
  </div>
  <div class="desc">
    Like map but allows duplicate keys. No operator[]. All operations: <strong>O(log n)</strong>.
  </div>

  <div class="method-card" data-search="multimap insert erase find count equal_range">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">insert / erase / find / count / equal_range</span>
      <span class="fn-desc">Core multimap operations</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre>multimap&lt;<span class="type">int</span>, string&gt; mm;
mm.<span class="fn">insert</span>({<span class="num">1</span>, <span class="str">"a"</span>});
mm.<span class="fn">insert</span>({<span class="num">1</span>, <span class="str">"b"</span>});   <span class="cmt">// allowed! duplicate keys</span>
mm.<span class="fn">emplace</span>(<span class="num">2</span>, <span class="str">"c"</span>);    <span class="cmt">// construct in-place</span>

mm.<span class="fn">count</span>(<span class="num">1</span>)            <span class="cmt">// O(log n + count) ‚Üí 2</span>
mm.<span class="fn">find</span>(<span class="num">1</span>)             <span class="cmt">// first entry with key 1</span>
mm.<span class="fn">erase</span>(<span class="num">1</span>)            <span class="cmt">// removes ALL entries with key 1</span>
mm.<span class="fn">erase</span>(it)           <span class="cmt">// remove single entry</span>

<span class="cmt">// Iterate all entries for a key:</span>
<span class="kw">auto</span> [lo, hi] = mm.<span class="fn">equal_range</span>(key);
<span class="kw">for</span> (<span class="kw">auto</span> it = lo; it != hi; ++it) {
    <span class="cmt">// it-&gt;first = key, it-&gt;second = value</span>
}

<span class="cmt">// ‚ö† No operator[] ‚Äî use insert() or find()</span>
mm.<span class="fn">size</span>()   mm.<span class="fn">empty</span>()   mm.<span class="fn">clear</span>()   mm.<span class="fn">swap</span>(mm2)</pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 14. UNORDERED MAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="unordered_map">
  <div class="section-header">
    <span class="num">14</span>
    <h2>Unordered Map (Hash Map)</h2>
    <span class="badge">&lt;unordered_map&gt; ¬∑ Hash Table</span>
  </div>
  <div class="desc">
    Hash table. Unique keys, no order. Average <strong>O(1)</strong>, worst <strong>O(n)</strong>.
  </div>

  <div class="method-card" data-search="unordered_map access bracket at insert emplace">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">[key] / at() / insert() / emplace()</span>
      <span class="fn-desc">Access and insert operations</span>
      <span class="complexity o1">O(1) average</span>
    </div>
    <div class="card-body">
      <pre>unordered_map&lt;string, <span class="type">int</span>&gt; um;
um[key]             <span class="cmt">// O(1) avg ‚Äî access/create (inserts default if missing!)</span>
um[key] = val       <span class="cmt">// O(1) avg ‚Äî insert or update</span>
um.<span class="fn">at</span>(key)          <span class="cmt">// O(1) avg ‚Äî throws if missing</span>
um.<span class="fn">insert</span>({k, v})   <span class="cmt">// O(1) avg ‚Äî insert only if key absent</span>
um.<span class="fn">emplace</span>(k, v)    <span class="cmt">// O(1) avg ‚Äî construct in-place</span>
um.<span class="fn">insert_or_assign</span>(k, v)  <span class="cmt">// C++17 ‚Äî insert or overwrite</span>
um.<span class="fn">try_emplace</span>(k, v)      <span class="cmt">// C++17 ‚Äî emplace only if key absent</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="unordered_map erase find count contains">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">erase / find / count / contains</span>
      <span class="fn-desc">Remove and search operations</span>
      <span class="complexity o1">O(1) average</span>
    </div>
    <div class="card-body">
      <pre>um.<span class="fn">erase</span>(key)       <span class="cmt">// O(1) avg ‚Äî remove by key</span>
um.<span class="fn">erase</span>(it)        <span class="cmt">// O(1) avg ‚Äî remove by iterator</span>
um.<span class="fn">find</span>(key)        <span class="cmt">// O(1) avg ‚Äî iterator or end()</span>
um.<span class="fn">count</span>(key)       <span class="cmt">// O(1) avg ‚Äî 0 or 1</span>
um.<span class="fn">contains</span>(key)    <span class="cmt">// O(1) avg ‚Äî C++20</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="unordered_map size empty clear reserve iterate">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">size / empty / clear / reserve / iteration</span>
      <span class="fn-desc">Utilities and traversal</span>
      <span class="complexity o1">O(1)*</span>
    </div>
    <div class="card-body">
      <pre>um.<span class="fn">size</span>()             <span class="cmt">// O(1)</span>
um.<span class="fn">empty</span>()            <span class="cmt">// O(1)</span>
um.<span class="fn">clear</span>()            <span class="cmt">// O(n)</span>
um.<span class="fn">reserve</span>(<span class="num">100</span>)       <span class="cmt">// pre-allocate (prevents rehashing)</span>
um.<span class="fn">swap</span>(um2)           <span class="cmt">// O(1)</span>

<span class="cmt">// Iteration (unordered!):</span>
<span class="kw">for</span> (<span class="kw">auto</span>&amp; [key, val] : um) { <span class="cmt">/* ... */</span> }</pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 15. ITERATORS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="iterators">
  <div class="section-header">
    <span class="num">15</span>
    <h2>Iterators</h2>
    <span class="badge">Iterator Utilities</span>
  </div>
  <div class="desc">
    Iterator categories: Input ‚Üí Forward ‚Üí Bidirectional ‚Üí Random Access
  </div>

  <div class="method-card" data-search="advance next prev distance iterators move">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">advance / next / prev / distance</span>
      <span class="fn-desc">Iterator movement and distance</span>
      <span class="complexity o1">O(1) random / O(n) others</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">advance</span>(it, n)      <span class="cmt">// move it n positions ‚Äî O(1) random, O(n) others</span>
<span class="fn">next</span>(it, n)         <span class="cmt">// returns iterator n ahead (default n=1)</span>
<span class="fn">prev</span>(it, n)         <span class="cmt">// returns iterator n back (default n=1)</span>
<span class="fn">distance</span>(it1, it2)  <span class="cmt">// count between ‚Äî O(1) random, O(n) others</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="iterator categories input forward bidirectional random access">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Iterator Categories</span>
      <span class="fn-desc">Hierarchy of iterator types</span>
      <span class="complexity other">Reference</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// Iterator Hierarchy (weakest ‚Üí strongest):</span>
<span class="cmt">// Input        ‚Üí read forward once  (istream)</span>
<span class="cmt">// Output       ‚Üí write forward once (ostream)</span>
<span class="cmt">// Forward      ‚Üí read/write, multi-pass (forward_list)</span>
<span class="cmt">// Bidirectional‚Üí + backward  (list, set, map)</span>
<span class="cmt">// Random Access‚Üí + jump O(1) (vector, deque, array)</span>

<span class="cmt">// begin/end pattern (works with all containers):</span>
<span class="kw">auto</span> it = c.<span class="fn">begin</span>();   <span class="cmt">// first element</span>
<span class="kw">auto</span> end = c.<span class="fn">end</span>();    <span class="cmt">// past-the-end</span>
<span class="kw">while</span> (it != end) { ++it; }

<span class="cmt">// Reverse iterators:</span>
<span class="kw">for</span> (<span class="kw">auto</span> rit = c.<span class="fn">rbegin</span>(); rit != c.<span class="fn">rend</span>(); ++rit) { }</pre>
    </div>
  </div>

  <div class="method-card" data-search="inserter back_inserter front_inserter output iterator">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Insert Iterators</span>
      <span class="fn-desc">back_inserter, front_inserter, inserter</span>
      <span class="complexity o1">O(1)*</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// Output iterators that insert into containers:</span>
<span class="fn">back_inserter</span>(v)     <span class="cmt">// calls push_back</span>
<span class="fn">front_inserter</span>(l)    <span class="cmt">// calls push_front (list/deque only)</span>
<span class="fn">inserter</span>(s, s.begin()) <span class="cmt">// calls insert at position</span>

<span class="cmt">// Example: copy filtered elements</span>
<span class="fn">copy_if</span>(v.begin(), v.end(), <span class="fn">back_inserter</span>(result),
        [](<span class="type">int</span> x) { <span class="kw">return</span> x &gt; <span class="num">0</span>; });</pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 16. ALGORITHMS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="algorithms">
  <div class="section-header">
    <span class="num">16</span>
    <h2>Algorithms</h2>
    <span class="badge">&lt;algorithm&gt; ¬∑ STL Algorithms</span>
  </div>
  <div class="desc">
    Comprehensive collection of algorithms for sorting, searching, modifying sequences.
  </div>

  <div class="method-card" data-search="sort stable_sort partial_sort nth_element">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Sorting Algorithms</span>
      <span class="fn-desc">sort, stable_sort, partial_sort</span>
      <span class="complexity onlogn">O(n log n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">sort</span>(v.begin(), v.end());                    <span class="cmt">// O(n log n) ‚Äî introsort</span>
<span class="fn">sort</span>(v.begin(), v.end(), greater&lt;<span class="type">int</span>&gt;());    <span class="cmt">// descending</span>
<span class="fn">stable_sort</span>(v.begin(), v.end());             <span class="cmt">// O(n log n) ‚Äî preserves order</span>
<span class="fn">partial_sort</span>(v.begin(), v.begin()+k, v.end()); <span class="cmt">// O(n log k) ‚Äî first k sorted</span>
<span class="fn">nth_element</span>(v.begin(), v.begin()+k, v.end());  <span class="cmt">// O(n) avg ‚Äî kth in place</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="binary_search lower_bound upper_bound find">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Searching Algorithms</span>
      <span class="fn-desc">Binary search (requires sorted)</span>
      <span class="complexity ologn">O(log n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">binary_search</span>(v.begin(), v.end(), x);        <span class="cmt">// O(log n) ‚Äî true/false</span>
<span class="fn">lower_bound</span>(v.begin(), v.end(), x);          <span class="cmt">// O(log n) ‚Äî first ‚â• x</span>
<span class="fn">upper_bound</span>(v.begin(), v.end(), x);          <span class="cmt">// O(log n) ‚Äî first &gt; x</span>
<span class="fn">find</span>(v.begin(), v.end(), x);                 <span class="cmt">// O(n) ‚Äî linear search</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="reverse rotate unique fill swap">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Modifying Algorithms</span>
      <span class="fn-desc">reverse, rotate, unique, fill</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">reverse</span>(v.begin(), v.end());                 <span class="cmt">// O(n)</span>
<span class="fn">rotate</span>(v.begin(), v.begin()+k, v.end());     <span class="cmt">// O(n) ‚Äî left rotate by k</span>
<span class="fn">unique</span>(v.begin(), v.end());                  <span class="cmt">// O(n) ‚Äî remove consecutive dups</span>
<span class="fn">fill</span>(v.begin(), v.end(), val);               <span class="cmt">// O(n)</span>
<span class="fn">swap</span>(a, b);                                  <span class="cmt">// O(1)</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="min_element max_element minmax_element">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Min/Max Algorithms</span>
      <span class="fn-desc">Finding minimum and maximum</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre>*<span class="fn">min_element</span>(v.begin(), v.end());            <span class="cmt">// O(n)</span>
*<span class="fn">max_element</span>(v.begin(), v.end());            <span class="cmt">// O(n)</span>
<span class="kw">auto</span> [mn, mx] = <span class="fn">minmax_element</span>(v.begin(), v.end()); <span class="cmt">// O(n) both</span>
<span class="fn">min</span>(a, b); <span class="fn">max</span>(a, b);                        <span class="cmt">// O(1)</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="next_permutation prev_permutation permutation">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Permutations</span>
      <span class="fn-desc">Generate permutations</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">next_permutation</span>(v.begin(), v.end());        <span class="cmt">// O(n) ‚Äî next lexicographic</span>
<span class="fn">prev_permutation</span>(v.begin(), v.end());        <span class="cmt">// O(n) ‚Äî previous</span>
<span class="cmt">// Returns false when wrapping around</span>

<span class="cmt">// Generate all permutations:</span>
<span class="fn">sort</span>(v.begin(), v.end());
<span class="kw">do</span> {
    <span class="cmt">// process current permutation</span>
} <span class="kw">while</span> (<span class="fn">next_permutation</span>(v.begin(), v.end()));</pre>
    </div>
  </div>

  <div class="method-card" data-search="count count_if for_each transform">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">count / count_if / for_each / transform</span>
      <span class="fn-desc">Counting, applying functions</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">count</span>(v.begin(), v.end(), val);                <span class="cmt">// O(n) ‚Äî count occurrences</span>
<span class="fn">count_if</span>(v.begin(), v.end(), pred);             <span class="cmt">// O(n) ‚Äî count matching predicate</span>
<span class="fn">for_each</span>(v.begin(), v.end(), func);             <span class="cmt">// O(n) ‚Äî apply function</span>
<span class="fn">transform</span>(v.begin(), v.end(), out.begin(), func);  <span class="cmt">// O(n) ‚Äî apply & store</span>

<span class="cmt">// Examples:</span>
<span class="type">int</span> evens = <span class="fn">count_if</span>(v.begin(), v.end(), [](<span class="type">int</span> x){ <span class="kw">return</span> x%<span class="num">2</span>==<span class="num">0</span>; });
<span class="fn">transform</span>(v.begin(), v.end(), v.begin(), [](<span class="type">int</span> x){ <span class="kw">return</span> x*<span class="num">2</span>; });</pre>
    </div>
  </div>

  <div class="method-card" data-search="all_of any_of none_of predicate check">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">all_of / any_of / none_of</span>
      <span class="fn-desc">Predicate checks on ranges</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">all_of</span>(v.begin(), v.end(), pred);   <span class="cmt">// true if ALL match</span>
<span class="fn">any_of</span>(v.begin(), v.end(), pred);   <span class="cmt">// true if ANY matches</span>
<span class="fn">none_of</span>(v.begin(), v.end(), pred);  <span class="cmt">// true if NONE match</span>

<span class="cmt">// Example:</span>
<span class="type">bool</span> allPos = <span class="fn">all_of</span>(v.begin(), v.end(), [](<span class="type">int</span> x){ <span class="kw">return</span> x &gt; <span class="num">0</span>; });</pre>
    </div>
  </div>

  <div class="method-card" data-search="copy copy_if copy_n remove remove_if erase">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">copy / copy_if / remove / remove_if</span>
      <span class="fn-desc">Copy and remove operations</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">copy</span>(v.begin(), v.end(), out.begin());         <span class="cmt">// O(n)</span>
<span class="fn">copy_if</span>(v.begin(), v.end(), <span class="fn">back_inserter</span>(r), pred); <span class="cmt">// O(n)</span>
<span class="fn">copy_n</span>(v.begin(), n, out.begin());              <span class="cmt">// copy first n</span>

<span class="cmt">// remove doesn't erase ‚Äî use erase-remove idiom:</span>
v.<span class="fn">erase</span>(<span class="fn">remove</span>(v.begin(), v.end(), val), v.end());
v.<span class="fn">erase</span>(<span class="fn">remove_if</span>(v.begin(), v.end(), pred), v.end());

<span class="cmt">// C++20: std::erase / std::erase_if (simplified):</span>
<span class="fn">erase</span>(v, val);         <span class="cmt">// remove all occurrences of val</span>
<span class="fn">erase_if</span>(v, pred);     <span class="cmt">// remove matching predicate</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="is_sorted merge includes set_union set_intersection set_difference">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">is_sorted / merge / set operations</span>
      <span class="fn-desc">Sorted range operations</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">is_sorted</span>(v.begin(), v.end());                <span class="cmt">// O(n) ‚Äî check if sorted</span>
<span class="fn">merge</span>(a.begin(), a.end(), b.begin(), b.end(),
      <span class="fn">back_inserter</span>(result));                    <span class="cmt">// O(n+m) ‚Äî merge sorted</span>
<span class="fn">inplace_merge</span>(v.begin(), v.begin()+k, v.end()); <span class="cmt">// O(n) ‚Äî merge in place</span>

<span class="cmt">// Set operations on SORTED ranges:</span>
<span class="fn">includes</span>(a.begin(), a.end(), b.begin(), b.end());        <span class="cmt">// is b ‚äÜ a?</span>
<span class="fn">set_union</span>(a.begin(), a.end(), b.begin(), b.end(), out);  <span class="cmt">// a ‚à™ b</span>
<span class="fn">set_intersection</span>(a.begin(), a.end(), b.begin(), b.end(), out); <span class="cmt">// a ‚à© b</span>
<span class="fn">set_difference</span>(a.begin(), a.end(), b.begin(), b.end(), out);   <span class="cmt">// a \ b</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="accumulate reduce iota numeric operations">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">accumulate / reduce</span>
      <span class="fn-desc">Reduction operations (from &lt;numeric&gt;)</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// #include &lt;numeric&gt;</span>
<span class="fn">accumulate</span>(v.begin(), v.end(), <span class="num">0</span>);              <span class="cmt">// O(n) ‚Äî sum</span>
<span class="fn">accumulate</span>(v.begin(), v.end(), <span class="num">1</span>, multiplies&lt;<span class="type">int</span>&gt;()); <span class="cmt">// product</span>
<span class="fn">reduce</span>(v.begin(), v.end());                    <span class="cmt">// C++17 ‚Äî parallel-friendly sum</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 17. NUMERIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="numeric">
  <div class="section-header">
    <span class="num">17</span>
    <h2>Numeric</h2>
    <span class="badge">&lt;numeric&gt; ¬∑ Mathematical Operations</span>
  </div>
  <div class="desc">
    Numeric algorithms for accumulation, prefix sums, GCD, LCM.
  </div>

  <div class="method-card" data-search="accumulate partial_sum iota sum prefix">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">accumulate / partial_sum / iota</span>
      <span class="fn-desc">Sum, prefix sums, sequence generation</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">#include &lt;numeric&gt;</span>
<span class="fn">accumulate</span>(v.begin(), v.end(), init);        <span class="cmt">// O(n) ‚Äî sum (init + v[0] + v[1] + ...)</span>
<span class="fn">partial_sum</span>(v.begin(), v.end(), out.begin()); <span class="cmt">// O(n) ‚Äî prefix sums</span>
<span class="fn">iota</span>(v.begin(), v.end(), start);             <span class="cmt">// O(n) ‚Äî fill start, start+1, start+2...</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="gcd lcm greatest common divisor least common multiple">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">gcd() / lcm()</span>
      <span class="fn-desc">Greatest common divisor and least common multiple</span>
      <span class="complexity ologn">O(log min(a,b))</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// C++17:</span>
<span class="fn">gcd</span>(a, b)   <span class="cmt">// greatest common divisor</span>
<span class="fn">lcm</span>(a, b)   <span class="cmt">// least common multiple</span>

<span class="cmt">// Example:</span>
<span class="fn">gcd</span>(<span class="num">12</span>, <span class="num">8</span>)   <span class="cmt">// ‚Üí 4</span>
<span class="fn">lcm</span>(<span class="num">12</span>, <span class="num">8</span>)   <span class="cmt">// ‚Üí 24</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="inner_product adjacent_difference reduce transform_reduce">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">inner_product / adjacent_difference / reduce</span>
      <span class="fn-desc">Advanced numeric algorithms</span>
      <span class="complexity on">O(n)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">inner_product</span>(a.begin(), a.end(), b.begin(), <span class="num">0</span>);
<span class="cmt">// O(n) ‚Äî dot product: init + a[0]*b[0] + a[1]*b[1] + ...</span>

<span class="fn">adjacent_difference</span>(v.begin(), v.end(), out.begin());
<span class="cmt">// O(n) ‚Äî out[0]=v[0], out[i]=v[i]-v[i-1]</span>

<span class="cmt">// C++17:</span>
<span class="fn">reduce</span>(v.begin(), v.end());                  <span class="cmt">// parallel-friendly sum</span>
<span class="fn">reduce</span>(v.begin(), v.end(), init, op);         <span class="cmt">// with custom operator</span>
<span class="fn">transform_reduce</span>(a.begin(), a.end(), b.begin(), <span class="num">0</span>);
<span class="cmt">// parallel-friendly inner product</span>

<span class="fn">exclusive_scan</span>(v.begin(), v.end(), out.begin(), <span class="num">0</span>);
<span class="cmt">// C++17 ‚Äî exclusive prefix sum (out[i] = sum of v[0..i-1])</span>
<span class="fn">inclusive_scan</span>(v.begin(), v.end(), out.begin());
<span class="cmt">// C++17 ‚Äî inclusive prefix sum (out[i] = sum of v[0..i])</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 18. BIT MANIPULATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="bits">
  <div class="section-header">
    <span class="num">18</span>
    <h2>Bit Manipulation</h2>
    <span class="badge">Bitwise Operations</span>
  </div>
  <div class="desc">
    Bitwise operators and GCC built-in functions for bit manipulation.
  </div>

  <div class="method-card" data-search="builtin popcount clz ctz parity">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">GCC Built-ins</span>
      <span class="fn-desc">popcount, clz, ctz, parity</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre><span class="fn">__builtin_popcount</span>(x)        <span class="cmt">// count set bits (int)</span>
<span class="fn">__builtin_popcountll</span>(x)      <span class="cmt">// count set bits (long long)</span>
<span class="fn">__builtin_clz</span>(x)             <span class="cmt">// count leading zeros</span>
<span class="fn">__builtin_ctz</span>(x)             <span class="cmt">// count trailing zeros</span>
<span class="fn">__builtin_parity</span>(x)          <span class="cmt">// 1 if odd number of set bits</span>
<span class="fn">__lg</span>(x)                      <span class="cmt">// floor(log2(x)) for x &gt; 0</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="bit tricks operations mask toggle">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Common Bit Tricks</span>
      <span class="fn-desc">Useful bit manipulation patterns</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre>x &amp; (x - <span class="num">1</span>)     <span class="cmt">// turn off rightmost set bit</span>
x &amp; (-x)        <span class="cmt">// isolate rightmost set bit</span>
(<span class="num">1</span> &lt;&lt; k)        <span class="cmt">// 2^k</span>
x &amp; (<span class="num">1</span> &lt;&lt; k)    <span class="cmt">// check if kth bit set</span>
x | (<span class="num">1</span> &lt;&lt; k)    <span class="cmt">// set kth bit</span>
x &amp; ~(<span class="num">1</span> &lt;&lt; k)   <span class="cmt">// clear kth bit</span>
x ^ (<span class="num">1</span> &lt;&lt; k)    <span class="cmt">// toggle kth bit</span>
(x &gt;&gt; k) &amp; <span class="num">1</span>    <span class="cmt">// get kth bit (0 or 1)</span>
(<span class="num">1</span> &lt;&lt; n) - <span class="num">1</span>    <span class="cmt">// n ones: 0..0111..1</span>

<span class="cmt">// Check power of 2:</span>
(x &amp; (x - <span class="num">1</span>)) == <span class="num">0</span> &amp;&amp; x &gt; <span class="num">0</span>

<span class="cmt">// Swap without temp:</span>
a ^= b; b ^= a; a ^= b;

<span class="cmt">// Iterate over set bits:</span>
<span class="kw">for</span> (<span class="type">int</span> t = x; t; t &amp;= (t - <span class="num">1</span>)) {
    <span class="type">int</span> bit = <span class="fn">__builtin_ctz</span>(t); <span class="cmt">// position of lowest set bit</span>
}

<span class="cmt">// Enumerate all submasks of a bitmask:</span>
<span class="kw">for</span> (<span class="type">int</span> sub = mask; sub; sub = (sub - <span class="num">1</span>) &amp; mask) {
    <span class="cmt">// process submask</span>
}</pre>
    </div>
  </div>

  <div class="method-card" data-search="bit C++20 popcount has_single_bit bit_ceil bit_floor countl_zero countr_zero">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">C++20 &lt;bit&gt; Header</span>
      <span class="fn-desc">Standard bit manipulation functions</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// #include &lt;bit&gt; ‚Äî C++20</span>
<span class="fn">popcount</span>(x)          <span class="cmt">// count set bits (unsigned)</span>
<span class="fn">has_single_bit</span>(x)    <span class="cmt">// true if x is power of 2</span>
<span class="fn">bit_ceil</span>(x)          <span class="cmt">// smallest power of 2 ‚â• x</span>
<span class="fn">bit_floor</span>(x)         <span class="cmt">// largest power of 2 ‚â§ x</span>
<span class="fn">countl_zero</span>(x)       <span class="cmt">// count leading zeros</span>
<span class="fn">countl_one</span>(x)        <span class="cmt">// count leading ones</span>
<span class="fn">countr_zero</span>(x)       <span class="cmt">// count trailing zeros</span>
<span class="fn">countr_one</span>(x)        <span class="cmt">// count trailing ones</span>
<span class="fn">bit_width</span>(x)         <span class="cmt">// min bits to represent x (‚åälog2(x)‚åã+1)</span>
<span class="fn">rotl</span>(x, n)           <span class="cmt">// rotate left by n</span>
<span class="fn">rotr</span>(x, n)           <span class="cmt">// rotate right by n</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 19. LAMBDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="lambda">
  <div class="section-header">
    <span class="num">19</span>
    <h2>Lambda & Comparators</h2>
    <span class="badge">C++11+ Features</span>
  </div>
  <div class="desc">
    Lambda expressions and custom comparators for STL containers and algorithms.
  </div>

  <div class="method-card" data-search="lambda capture syntax expression">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Lambda Syntax & Capture</span>
      <span class="fn-desc">Lambda expressions with different captures</span>
      <span class="complexity other">Reference</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// Lambda: [capture](params) -&gt; return_type { body }</span>
<span class="kw">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) { <span class="kw">return</span> a + b; };
<span class="kw">auto</span> square = [](<span class="type">int</span> x) -&gt; <span class="type">int</span> { <span class="kw">return</span> x * x; };

<span class="cmt">// Capture modes:</span>
<span class="cmt">// [x]()     ‚Äî capture x by value (copy)</span>
<span class="cmt">// [&amp;x]()    ‚Äî capture x by reference</span>
<span class="cmt">// [=]()     ‚Äî capture all by value</span>
<span class="cmt">// [&amp;]()     ‚Äî capture all by reference</span>
<span class="cmt">// [=, &amp;x]() ‚Äî all by value, x by reference</span>
<span class="cmt">// [&amp;, x]()  ‚Äî all by reference, x by value</span>

<span class="cmt">// Mutable lambda (modify captured values):</span>
<span class="type">int</span> count = <span class="num">0</span>;
<span class="kw">auto</span> counter = [count]() <span class="kw">mutable</span> { <span class="kw">return</span> ++count; };</pre>
    </div>
  </div>

  <div class="method-card" data-search="comparator sort priority_queue set map custom ordering">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Custom Comparators</span>
      <span class="fn-desc">For sort, set, map, priority_queue</span>
      <span class="complexity other">Reference</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// Custom comparator for sort:</span>
<span class="fn">sort</span>(v.begin(), v.end(), [](<span class="kw">auto</span>&amp; a, <span class="kw">auto</span>&amp; b) {
    <span class="kw">return</span> a.second &lt; b.second;
});

<span class="cmt">// Comparator for priority_queue (reversed logic!):</span>
<span class="kw">auto</span> cmp = [](<span class="type">int</span> a, <span class="type">int</span> b) { <span class="kw">return</span> a &gt; b; }; <span class="cmt">// min-heap</span>

<span class="cmt">// Comparator struct for set/map:</span>
<span class="kw">struct</span> Cmp {
    <span class="type">bool</span> <span class="kw">operator</span>()(<span class="type">int</span> a, <span class="type">int</span> b) <span class="kw">const</span> { <span class="kw">return</span> a &gt; b; }
};
set&lt;<span class="type">int</span>, Cmp&gt; s;  <span class="cmt">// descending set</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 20. TUPLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="tuple">
  <div class="section-header">
    <span class="num">20</span>
    <h2>Tuple</h2>
    <span class="badge">&lt;tuple&gt; ¬∑ Multiple Values</span>
  </div>
  <div class="desc">
    Fixed-size collection of heterogeneous values. Like pair but for any number of elements.
  </div>

  <div class="method-card" data-search="tuple make_tuple get tie structured bindings">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Creation & Access</span>
      <span class="fn-desc">make_tuple, get, tie, structured bindings</span>
      <span class="complexity o1">O(1)</span>
    </div>
    <div class="card-body">
      <pre><span class="cmt">// Creation:</span>
tuple&lt;<span class="type">int</span>, string, <span class="type">double</span>&gt; t(<span class="num">1</span>, <span class="str">"hello"</span>, <span class="num">3.14</span>);
<span class="kw">auto</span> t2 = <span class="fn">make_tuple</span>(<span class="num">1</span>, <span class="str">"hello"</span>, <span class="num">3.14</span>);

<span class="cmt">// Access by index:</span>
<span class="fn">get</span>&lt;<span class="num">0</span>&gt;(t)     <span class="cmt">// ‚Üí 1  (first element)</span>
<span class="fn">get</span>&lt;<span class="num">1</span>&gt;(t)     <span class="cmt">// ‚Üí "hello"</span>
<span class="fn">get</span>&lt;<span class="num">2</span>&gt;(t)     <span class="cmt">// ‚Üí 3.14</span>

<span class="cmt">// C++17 structured bindings:</span>
<span class="kw">auto</span> [x, y, z] = t;

<span class="cmt">// Tie (unpack into existing variables):</span>
<span class="type">int</span> a; string b; <span class="type">double</span> c;
<span class="fn">tie</span>(a, b, c) = t;
<span class="fn">tie</span>(a, <span class="fn">ignore</span>, c) = t;  <span class="cmt">// skip middle element</span>

<span class="cmt">// Comparison: lexicographic (like pair)</span>
<span class="cmt">// tuple_size&lt;decltype(t)&gt;::value ‚Üí 3</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 21. ARRAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="stdarray">
  <div class="section-header">
    <span class="num">21</span>
    <h2>std::array</h2>
    <span class="badge">&lt;array&gt; ¬∑ Fixed-Size Array</span>
  </div>
  <div class="desc">
    Fixed-size array with STL interface. Size known at compile time. <strong>O(1)</strong> random access, no heap allocation.
  </div>

  <div class="method-card" data-search="array declaration access fill size">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Declaration & Operations</span>
      <span class="fn-desc">Creation, access, fill, sort</span>
      <span class="complexity o1">O(1) access</span>
    </div>
    <div class="card-body">
      <pre>array&lt;<span class="type">int</span>, <span class="num">5</span>&gt; arr = {<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>};
array&lt;<span class="type">int</span>, <span class="num">5</span>&gt; arr2{};     <span class="cmt">// zero-initialized</span>

arr[i]              <span class="cmt">// O(1) ‚Äî no bounds check</span>
arr.<span class="fn">at</span>(i)           <span class="cmt">// O(1) ‚Äî bounds checked</span>
arr.<span class="fn">front</span>()         <span class="cmt">// O(1) ‚Äî first element</span>
arr.<span class="fn">back</span>()          <span class="cmt">// O(1) ‚Äî last element</span>
arr.<span class="fn">data</span>()          <span class="cmt">// O(1) ‚Äî raw pointer</span>
arr.<span class="fn">size</span>()          <span class="cmt">// O(1) ‚Äî compile-time constant</span>
arr.<span class="fn">empty</span>()         <span class="cmt">// O(1)</span>
arr.<span class="fn">fill</span>(<span class="num">0</span>)         <span class="cmt">// O(n) ‚Äî fill all with value</span>
arr.<span class="fn">swap</span>(arr2)      <span class="cmt">// O(n) ‚Äî swap contents</span>

<span class="cmt">// Works with all STL algorithms:</span>
<span class="fn">sort</span>(arr.begin(), arr.end());
<span class="fn">reverse</span>(arr.begin(), arr.end());</pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 22. BITSET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="bitset">
  <div class="section-header">
    <span class="num">22</span>
    <h2>Bitset</h2>
    <span class="badge">&lt;bitset&gt; ¬∑ Fixed-Size Bit Array</span>
  </div>
  <div class="desc">
    Fixed-size sequence of bits. Size must be compile-time constant. Operations are <strong>O(N/64)</strong> ‚Äî 64x faster than bool array.
  </div>

  <div class="method-card" data-search="bitset declaration set reset flip test count">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Declaration & Bit Operations</span>
      <span class="fn-desc">Creation, set, reset, flip, test</span>
      <span class="complexity o1">O(1) per bit / O(N/64) bulk</span>
    </div>
    <div class="card-body">
      <pre>bitset&lt;<span class="num">8</span>&gt; b;                  <span class="cmt">// 00000000</span>
bitset&lt;<span class="num">8</span>&gt; b(<span class="num">42</span>);             <span class="cmt">// 00101010</span>
bitset&lt;<span class="num">8</span>&gt; b(<span class="str">"11001010"</span>);     <span class="cmt">// from string</span>

b.<span class="fn">set</span>()            <span class="cmt">// set all bits to 1</span>
b.<span class="fn">set</span>(i)           <span class="cmt">// set bit i to 1</span>
b.<span class="fn">set</span>(i, <span class="num">0</span>)        <span class="cmt">// set bit i to 0</span>
b.<span class="fn">reset</span>()          <span class="cmt">// set all bits to 0</span>
b.<span class="fn">reset</span>(i)         <span class="cmt">// set bit i to 0</span>
b.<span class="fn">flip</span>()           <span class="cmt">// toggle all bits</span>
b.<span class="fn">flip</span>(i)          <span class="cmt">// toggle bit i</span>
b.<span class="fn">test</span>(i)          <span class="cmt">// check bit i (bounds checked)</span>
b[i]              <span class="cmt">// check/set bit i (no bounds check)</span></pre>
    </div>
  </div>

  <div class="method-card" data-search="bitset count any all none bitwise operators to_string to_ulong">
    <div class="card-head" onclick="toggle(this)">
      <span class="chevron">‚ñ∂</span>
      <span class="fn-name">Queries & Operators</span>
      <span class="fn-desc">count, any, all, none, bitwise ops</span>
      <span class="complexity other">O(N/64)</span>
    </div>
    <div class="card-body">
      <pre>b.<span class="fn">count</span>()          <span class="cmt">// number of set bits ‚Äî O(N/64)</span>
b.<span class="fn">any</span>()            <span class="cmt">// true if any bit set</span>
b.<span class="fn">all</span>()            <span class="cmt">// true if all bits set</span>
b.<span class="fn">none</span>()           <span class="cmt">// true if no bits set</span>
b.<span class="fn">size</span>()           <span class="cmt">// total number of bits</span>

<span class="cmt">// Bitwise operators ‚Äî O(N/64):</span>
b1 &amp; b2    b1 | b2    b1 ^ b2    ~b1
b &lt;&lt; n     b &gt;&gt; n
b1 == b2   b1 != b2

<span class="cmt">// Conversion:</span>
b.<span class="fn">to_string</span>()      <span class="cmt">// ‚Üí "00101010"</span>
b.<span class="fn">to_ulong</span>()       <span class="cmt">// ‚Üí unsigned long</span>
b.<span class="fn">to_ullong</span>()      <span class="cmt">// ‚Üí unsigned long long</span></pre>
    </div>
  </div>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPLEXITY TABLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="complexity">
  <div class="section-header">
    <span class="num">üìä</span>
    <h2>Time Complexity Summary</h2>
  </div>
  <div style="overflow-x:auto">
  <table class="complexity-table">
    <thead>
      <tr><th>Container</th><th>Access</th><th>Insert</th><th>Delete</th><th>Search</th><th>Ordered?</th></tr>
    </thead>
    <tbody>
      <tr><td class="ds-name">vector</td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity on">O(n)*</span></td><td><span class="complexity on">O(n)*</span></td><td><span class="complexity on">O(n)</span></td><td>No</td></tr>
      <tr><td class="ds-name">list</td><td><span class="complexity on">O(n)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity on">O(n)</span></td><td>No</td></tr>
      <tr><td class="ds-name">deque</td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)**</span></td><td><span class="complexity o1">O(1)**</span></td><td><span class="complexity on">O(n)</span></td><td>No</td></tr>
      <tr><td class="ds-name">set</td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td>Yes</td></tr>
      <tr><td class="ds-name">multiset</td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td>Yes</td></tr>
      <tr><td class="ds-name">unordered_set</td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td>No</td></tr>
      <tr><td class="ds-name">map</td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td>Yes</td></tr>
      <tr><td class="ds-name">multimap</td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td>Yes</td></tr>
      <tr><td class="ds-name">unordered_map</td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td>No</td></tr>
      <tr><td class="ds-name">stack</td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td>N/A</td><td>N/A</td></tr>
      <tr><td class="ds-name">queue</td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td>N/A</td><td>N/A</td></tr>
      <tr><td class="ds-name">priority_queue</td><td><span class="complexity o1">O(1) top</span></td><td><span class="complexity ologn">O(log n)</span></td><td><span class="complexity ologn">O(log n)</span></td><td>N/A</td><td>N/A</td></tr>
      <tr><td class="ds-name">array</td><td><span class="complexity o1">O(1)</span></td><td>N/A</td><td>N/A</td><td><span class="complexity on">O(n)</span></td><td>No</td></tr>
      <tr><td class="ds-name">bitset</td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td><span class="complexity o1">O(1)</span></td><td>No</td></tr>
    </tbody>
  </table>
  </div>
  <p style="margin-top:8px;font-size:.78rem;color:var(--text-muted)">* vector: O(1) amortized at end. ** deque: O(1) at both ends, O(n) in middle. unordered: O(1) average, O(n) worst case.</p>
</section>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMMON PATTERNS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<section class="section" id="patterns">
  <div class="section-header">
    <span class="num">üí°</span>
    <h2>Common DSA Patterns</h2>
  </div>

  <div class="pattern-card">
    <h3>Two Pointers <span class="badge-pattern">O(n)</span></h3>
    <p>Use: sorted arrays, pair sum, remove duplicates, container with water</p>
    <pre><span class="cmt">// Example: Two Sum in sorted array</span>
<span class="type">int</span> left = <span class="num">0</span>, right = n - <span class="num">1</span>;
<span class="kw">while</span> (left &lt; right) {
    <span class="type">int</span> sum = arr[left] + arr[right];
    <span class="kw">if</span> (sum == target) { <span class="cmt">/* found */</span> <span class="kw">break</span>; }
    <span class="kw">else if</span> (sum &lt; target) left++;
    <span class="kw">else</span> right--;
}</pre>
  </div>

  <div class="pattern-card">
    <h3>Sliding Window <span class="badge-pattern">O(n)</span></h3>
    <p>Use: subarray problems ‚Äî max/min sum of size k, longest substring without repeats</p>
    <pre><span class="cmt">// Example: Maximum sum subarray of size k</span>
<span class="type">int</span> maxSum = <span class="num">0</span>, windowSum = <span class="num">0</span>;
<span class="kw">for</span> (<span class="type">int</span> i = <span class="num">0</span>; i &lt; n; i++) {
    windowSum += arr[i];
    <span class="kw">if</span> (i &gt;= k) windowSum -= arr[i - k];
    <span class="kw">if</span> (i &gt;= k - <span class="num">1</span>) maxSum = <span class="fn">max</span>(maxSum, windowSum);
}</pre>
  </div>

  <div class="pattern-card">
    <h3>Kadane's Algorithm <span class="badge-pattern">O(n)</span></h3>
    <p>Use: maximum subarray sum (contiguous), can extend to max product, circular arrays</p>
    <pre><span class="cmt">// Maximum subarray sum</span>
<span class="type">int</span> maxSum = arr[<span class="num">0</span>], curSum = arr[<span class="num">0</span>];
<span class="kw">for</span> (<span class="type">int</span> i = <span class="num">1</span>; i &lt; n; i++) {
    curSum = <span class="fn">max</span>(arr[i], curSum + arr[i]);
    maxSum = <span class="fn">max</span>(maxSum, curSum);
}</pre>
  </div>

  <div class="pattern-card">
    <h3>Binary Search <span class="badge-pattern">O(log n)</span></h3>
    <p>Use: sorted data, search space reduction, answer on monotonic function</p>
    <pre><span class="cmt">// Find first occurrence</span>
<span class="type">int</span> lo = <span class="num">0</span>, hi = n - <span class="num">1</span>, ans = -<span class="num">1</span>;
<span class="kw">while</span> (lo &lt;= hi) {
    <span class="type">int</span> mid = lo + (hi - lo) / <span class="num">2</span>;
    <span class="kw">if</span> (arr[mid] == target) { ans = mid; hi = mid - <span class="num">1</span>; }
    <span class="kw">else if</span> (arr[mid] &lt; target) lo = mid + <span class="num">1</span>;
    <span class="kw">else</span> hi = mid - <span class="num">1</span>;
}</pre>
  </div>

  <div class="pattern-card">
    <h3>Prefix Sum <span class="badge-pattern">O(n) build, O(1) query</span></h3>
    <p>Use: range sum queries O(1) after O(n) preprocess, subarray sum equals k</p>
    <pre><span class="cmt">// Range sum query [l, r]</span>
vector&lt;<span class="type">int</span>&gt; prefix(n + <span class="num">1</span>, <span class="num">0</span>);
<span class="kw">for</span> (<span class="type">int</span> i = <span class="num">0</span>; i &lt; n; i++) 
    prefix[i + <span class="num">1</span>] = prefix[i] + arr[i];
<span class="type">int</span> rangeSum = prefix[r + <span class="num">1</span>] - prefix[l];</pre>
  </div>

  <div class="pattern-card">
    <h3>Monotonic Stack <span class="badge-pattern">O(n)</span></h3>
    <p>Use: next greater/smaller element, largest rectangle in histogram, stock span</p>
    <pre><span class="cmt">// Next Greater Element</span>
vector&lt;<span class="type">int</span>&gt; nge(n, -<span class="num">1</span>);
stack&lt;<span class="type">int</span>&gt; st;
<span class="kw">for</span> (<span class="type">int</span> i = <span class="num">0</span>; i &lt; n; i++) {
    <span class="kw">while</span> (!st.<span class="fn">empty</span>() &amp;&amp; arr[st.<span class="fn">top</span>()] &lt; arr[i]) {
        nge[st.<span class="fn">top</span>()] = arr[i];
        st.<span class="fn">pop</span>();
    }
    st.<span class="fn">push</span>(i);
}</pre>
  </div>

  <div class="pattern-card">
    <h3>BFS / DFS <span class="badge-pattern">O(V + E)</span></h3>
    <p>Use: graph traversal, connected components, shortest path (unweighted), cycle detection</p>
    <pre><span class="cmt">// BFS ‚Äî shortest path in unweighted graph</span>
vector&lt;<span class="type">int</span>&gt; dist(V, -<span class="num">1</span>);
queue&lt;<span class="type">int</span>&gt; q;
dist[src] = <span class="num">0</span>; q.<span class="fn">push</span>(src);
<span class="kw">while</span> (!q.<span class="fn">empty</span>()) {
    <span class="type">int</span> u = q.<span class="fn">front</span>(); q.<span class="fn">pop</span>();
    <span class="kw">for</span> (<span class="type">int</span> v : adj[u]) {
        <span class="kw">if</span> (dist[v] == -<span class="num">1</span>) { 
            dist[v] = dist[u] + <span class="num">1</span>; 
            q.<span class="fn">push</span>(v); 
        }
    }
}</pre>
  </div>

  <div class="pattern-card">
    <h3>Dijkstra <span class="badge-pattern">O((V+E) log V)</span></h3>
    <p>Use: shortest path in weighted graph (non-negative weights)</p>
    <pre><span class="cmt">// Single-source shortest path</span>
vector&lt;<span class="type">int</span>&gt; dist(V, INT_MAX);
priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;
dist[src] = <span class="num">0</span>; pq.<span class="fn">push</span>({<span class="num">0</span>, src});
<span class="kw">while</span> (!pq.<span class="fn">empty</span>()) {
    <span class="kw">auto</span> [d, u] = pq.<span class="fn">top</span>(); pq.<span class="fn">pop</span>();
    <span class="kw">if</span> (d &gt; dist[u]) <span class="kw">continue</span>;
    <span class="kw">for</span> (<span class="kw">auto</span> [v, w] : adj[u]) {
        <span class="kw">if</span> (dist[u] + w &lt; dist[v]) {
            dist[v] = dist[u] + w;
            pq.<span class="fn">push</span>({dist[v], v});
        }
    }
}</pre>
  </div>

  <div class="pattern-card">
    <h3>Union-Find (DSU) <span class="badge-pattern">O(Œ±(n)) ‚âà O(1)</span></h3>
    <p>Use: connected components, cycle detection, Kruskal's MST</p>
    <pre>vector&lt;<span class="type">int</span>&gt; parent(n), rank_(n, <span class="num">0</span>);
<span class="fn">iota</span>(parent.begin(), parent.end(), <span class="num">0</span>);

<span class="type">int</span> <span class="fn">find</span>(<span class="type">int</span> x) {
    <span class="kw">if</span> (parent[x] != x) 
        parent[x] = <span class="fn">find</span>(parent[x]);
    <span class="kw">return</span> parent[x];
}

<span class="type">void</span> <span class="fn">unite</span>(<span class="type">int</span> a, <span class="type">int</span> b) {
    a = <span class="fn">find</span>(a); b = <span class="fn">find</span>(b);
    <span class="kw">if</span> (a == b) <span class="kw">return</span>;
    <span class="kw">if</span> (rank_[a] &lt; rank_[b]) <span class="fn">swap</span>(a, b);
    parent[b] = a;
    <span class="kw">if</span> (rank_[a] == rank_[b]) rank_[a]++;
}</pre>
  </div>

  <div class="pattern-card">
    <h3>Dynamic Programming <span class="badge-pattern">varies</span></h3>
    <p>Use: overlapping subproblems + optimal substructure (knapsack, LIS, LCS, coin change)</p>
    <pre><span class="cmt">// 0/1 Knapsack</span>
vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp(n + <span class="num">1</span>, vector&lt;<span class="type">int</span>&gt;(W + <span class="num">1</span>, <span class="num">0</span>));
<span class="kw">for</span> (<span class="type">int</span> i = <span class="num">1</span>; i &lt;= n; i++)
    <span class="kw">for</span> (<span class="type">int</span> w = <span class="num">0</span>; w &lt;= W; w++) {
        dp[i][w] = dp[i-<span class="num">1</span>][w];
        <span class="kw">if</span> (wt[i-<span class="num">1</span>] &lt;= w)
            dp[i][w] = <span class="fn">max</span>(dp[i][w], dp[i-<span class="num">1</span>][w - wt[i-<span class="num">1</span>]] + val[i-<span class="num">1</span>]);
    }</pre>
  </div>

  <div class="pattern-card">
    <h3>Topological Sort (Kahn's BFS) <span class="badge-pattern">O(V + E)</span></h3>
    <p>Use: DAG ordering, course scheduling, dependency resolution, build systems</p>
    <pre><span class="cmt">// BFS-based (Kahn's Algorithm)</span>
vector&lt;<span class="type">int</span>&gt; indegree(V, <span class="num">0</span>);
<span class="kw">for</span> (<span class="type">int</span> u = <span class="num">0</span>; u &lt; V; u++)
    <span class="kw">for</span> (<span class="type">int</span> v : adj[u]) indegree[v]++;

queue&lt;<span class="type">int</span>&gt; q;
<span class="kw">for</span> (<span class="type">int</span> i = <span class="num">0</span>; i &lt; V; i++)
    <span class="kw">if</span> (indegree[i] == <span class="num">0</span>) q.<span class="fn">push</span>(i);

vector&lt;<span class="type">int</span>&gt; topo;
<span class="kw">while</span> (!q.<span class="fn">empty</span>()) {
    <span class="type">int</span> u = q.<span class="fn">front</span>(); q.<span class="fn">pop</span>();
    topo.<span class="fn">push_back</span>(u);
    <span class="kw">for</span> (<span class="type">int</span> v : adj[u])
        <span class="kw">if</span> (--indegree[v] == <span class="num">0</span>) q.<span class="fn">push</span>(v);
}
<span class="cmt">// if topo.size() != V ‚Üí cycle exists!</span></pre>
  </div>

  <div class="pattern-card">
    <h3>Trie (Prefix Tree) <span class="badge-pattern">O(L) per operation</span></h3>
    <p>Use: string prefix matching, autocomplete, dictionary, word search</p>
    <pre><span class="kw">struct</span> TrieNode {
    TrieNode* children[<span class="num">26</span>] = {};
    <span class="type">bool</span> isEnd = <span class="kw">false</span>;
};

<span class="kw">class</span> Trie {
    TrieNode* root = <span class="kw">new</span> TrieNode();
<span class="kw">public</span>:
    <span class="type">void</span> <span class="fn">insert</span>(string&amp; s) {
        <span class="kw">auto</span> node = root;
        <span class="kw">for</span> (<span class="type">char</span> c : s) {
            <span class="kw">if</span> (!node-&gt;children[c-<span class="str">'a'</span>])
                node-&gt;children[c-<span class="str">'a'</span>] = <span class="kw">new</span> TrieNode();
            node = node-&gt;children[c-<span class="str">'a'</span>];
        }
        node-&gt;isEnd = <span class="kw">true</span>;
    }
    <span class="type">bool</span> <span class="fn">search</span>(string&amp; s) {
        <span class="kw">auto</span> node = root;
        <span class="kw">for</span> (<span class="type">char</span> c : s) {
            <span class="kw">if</span> (!node-&gt;children[c-<span class="str">'a'</span>]) <span class="kw">return false</span>;
            node = node-&gt;children[c-<span class="str">'a'</span>];
        }
        <span class="kw">return</span> node-&gt;isEnd;
    }
};</pre>
  </div>

  <div class="pattern-card">
    <h3>Fast I/O & Competitive Programming Tips <span class="badge-pattern">Reference</span></h3>
    <p>Use: competitive programming, speed up I/O, common macros</p>
    <pre><span class="cmt">// Fast I/O (must-have for competitive programming):</span>
ios_base::<span class="fn">sync_with_stdio</span>(<span class="kw">false</span>);
cin.<span class="fn">tie</span>(NULL);

<span class="cmt">// Use '\n' instead of endl (endl flushes buffer)</span>

<span class="cmt">// Common type aliases:</span>
<span class="kw">typedef</span> <span class="type">long long</span> ll;
<span class="kw">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;
<span class="kw">typedef</span> vector&lt;<span class="type">int</span>&gt; vi;

<span class="cmt">// MOD arithmetic:</span>
<span class="kw">const</span> <span class="type">int</span> MOD = <span class="num">1e9</span> + <span class="num">7</span>;
ll <span class="fn">power</span>(ll base, ll exp, ll mod) {
    ll result = <span class="num">1</span>;
    base %= mod;
    <span class="kw">while</span> (exp &gt; <span class="num">0</span>) {
        <span class="kw">if</span> (exp &amp; <span class="num">1</span>) result = result * base % mod;
        base = base * base % mod;
        exp &gt;&gt;= <span class="num">1</span>;
    }
    <span class="kw">return</span> result;
}</pre>
  </div>

</section>

<footer style="text-align:center;padding:32px 0 16px;color:var(--text-muted);font-size:.8rem;border-top:1px solid var(--surface2);margin-top:40px">
  C++ STL & DSA Reference ¬∑ C++11/14/17/20/23 ¬∑ Comprehensive Guide for Competitive Programming
</footer>

</main>

<!-- ‚ïê‚ïê‚ïê BACK TO TOP ‚ïê‚ïê‚ïê -->
<button class="btt" id="btt" onclick="window.scrollTo({top:0})" title="Back to top">‚Üë</button>

<script>
// ‚îÄ‚îÄ Toggle method cards ‚îÄ‚îÄ
function toggle(head) {
  head.parentElement.classList.toggle('open');
}

// ‚îÄ‚îÄ Active sidebar link tracking ‚îÄ‚îÄ
const sections = document.querySelectorAll('.section');
const navLinks = document.querySelectorAll('.sidebar a');
const observer = new IntersectionObserver(entries => {
  entries.forEach(e => {
    if (e.isIntersecting) {
      navLinks.forEach(l => l.classList.remove('active'));
      const link = document.querySelector(`.sidebar a[href="#${e.target.id}"]`);
      if (link) link.classList.add('active');
    }
  });
}, { rootMargin: '-80px 0px -60% 0px' });
sections.forEach(s => observer.observe(s));

// ‚îÄ‚îÄ Close mobile sidebar on link click ‚îÄ‚îÄ
navLinks.forEach(l => l.addEventListener('click', () => {
  document.getElementById('sidebar').classList.remove('open');
}));

// ‚îÄ‚îÄ Back to top button ‚îÄ‚îÄ
window.addEventListener('scroll', () => {
  document.getElementById('btt').classList.toggle('show', window.scrollY > 400);
});

// ‚îÄ‚îÄ Search ‚îÄ‚îÄ
const searchInput = document.getElementById('searchInput');
const searchOverlay = document.getElementById('searchOverlay');
const searchResults = document.getElementById('searchResults');

// Build search index
const searchIndex = [];
document.querySelectorAll('.method-card, .pattern-card').forEach(card => {
  const section = card.closest('.section');
  const sectionTitle = section.querySelector('h2')?.textContent || '';
  const fnName = card.querySelector('.fn-name')?.textContent || card.querySelector('h3')?.textContent || '';
  const fnDesc = card.querySelector('.fn-desc')?.textContent || card.querySelector('p')?.textContent || '';
  const searchData = card.dataset.search || '';
  const bodyText = card.textContent || '';
  searchIndex.push({
    el: card, sectionId: section.id, sectionTitle, fnName, fnDesc,
    text: `${fnName} ${fnDesc} ${searchData} ${bodyText}`.toLowerCase()
  });
});

function openSearch() { searchOverlay.classList.add('show'); searchInput.focus(); }
function closeSearch() { searchOverlay.classList.remove('show'); searchResults.innerHTML = ''; }

searchInput.addEventListener('input', function() {
  const q = this.value.trim().toLowerCase();
  if (!q) { closeSearch(); return; }
  openSearch();
  const results = searchIndex.filter(item => {
    return q.split(/\s+/).every(word => item.text.includes(word));
  }).slice(0, 15);

  if (!results.length) {
    searchResults.innerHTML = '<div class="sr-empty">No results found</div>';
    return;
  }
  searchResults.innerHTML = results.map((r, i) => {
    let title = r.fnName;
    const regex = new RegExp(`(${q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
    title = title.replace(regex, '<mark>$1</mark>');
    return `<div class="sr-item${i===0?' active':''}" data-section="${r.sectionId}" data-el-idx="${searchIndex.indexOf(r)}">
      <span class="sr-title">${title}</span>
      <span class="sr-section">${r.sectionTitle} ¬∑ ${r.fnDesc.substring(0, 60)}</span>
    </div>`;
  }).join('');

  searchResults.querySelectorAll('.sr-item').forEach(item => {
    item.addEventListener('click', () => {
      const idx = parseInt(item.dataset.elIdx);
      const target = searchIndex[idx];
      target.el.classList.add('open');
      target.el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      target.el.style.borderColor = 'var(--accent)';
      setTimeout(() => target.el.style.borderColor = '', 2000);
      closeSearch();
      searchInput.value = '';
    });
  });
});

// Keyboard shortcut
document.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
    e.preventDefault();
    searchInput.focus();
    searchInput.select();
  }
  if (e.key === 'Escape') {
    closeSearch();
    searchInput.blur();
  }
});

// Expand all / collapse all with keyboard
document.addEventListener('keydown', e => {
  if (e.key === 'e' && e.altKey) {
    const cards = document.querySelectorAll('.method-card');
    const allOpen = [...cards].every(c => c.classList.contains('open'));
    cards.forEach(c => c.classList.toggle('open', !allOpen));
  }
});
</script>
</body>
</html>
